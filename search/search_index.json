{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Django Shinobi - Fast Django REST Framework","text":"<p>Django Shinobi is a web framework for building APIs with Django and Python 3.6+ type hints.</p> <p>It's a fork of the fantastic Django Ninja library focused on community-desired features and fixes. Check out the list of differences if you're coming from Ninja, as well as the roadmap!</p> <p>Key features:</p> <ul> <li>Easy: Designed to be easy to use and intuitive.</li> <li>FAST execution: Very high performance thanks to Pydantic and async support. </li> <li>Fast to code: Type hints and automatic docs lets you focus only on business logic.</li> <li>Standards-based: Based on the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema.</li> <li>Django friendly: (obviously) has good integration with the Django core and ORM.</li> <li>Production ready: The original Ninja project is used by multiple companies on live projects.</li> </ul> <p>Benchmarks:</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>In your Django project, add Django Shinobi.</p> <pre><code>pip install django-shinobi\n</code></pre> <p>or start a new project.</p> <pre><code>pip install django django-shinobi\ndjango-admin startproject apidemo\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>In your Django project, next to urls.py, create a new file called <code>api.py</code>.</p> <pre><code>from django.contrib import admin\nfrom django.urls import path\nfrom ninja import NinjaAPI\n\napi = NinjaAPI()\n\n\n@api.get(\"/add\")\ndef add(request, a: int, b: int):\n    return {\"result\": a + b}\n\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"api/\", api.urls),\n]\n</code></pre> <p>Now go to <code>urls.py</code> and add the following:</p> <pre><code>...\nfrom .api import api\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"api/\", api.urls),  # &lt;---------- !\n]\n</code></pre> <p>That's it !</p> <p>Now you've just created an API that:</p> <ul> <li>receives an HTTP GET request at <code>/api/add</code></li> <li>takes, validates and type-casts GET parameters <code>a</code> and <code>b</code></li> <li>decodes the result to JSON</li> <li>generates an OpenAPI schema for defined operation</li> </ul>"},{"location":"#interactive-api-docs","title":"Interactive API docs","text":"<p>Run your Django project</p> <pre><code>python manage.py runsever\n</code></pre> <p>Now go to http://127.0.0.1:8000/api/docs</p> <p>You will see the automatic interactive API documentation (provided by Swagger UI or Redoc):</p> <p></p>"},{"location":"#recap","title":"Recap","text":"<p>In summary, you declare the types of parameters, body, etc. once only, as function parameters.</p> <p>You do that with standard modern Python types.</p> <p>You don't have to learn a new syntax, the methods or classes of a specific library, etc.</p> <p>Just standard Python 3.6+.</p> <p>For example, for an <code>int</code>:</p> <pre><code>a: int\n</code></pre> <p>or, for a more complex <code>Item</code> model:</p> <pre><code>class Item(Schema):\n    foo: str\n    bar: float\n\ndef operation(a: Item):\n    ...\n</code></pre> <p>... and with that single declaration you get:</p> <ul> <li>Editor support, including:<ul> <li>Completion</li> <li>Type checks</li> </ul> </li> <li>Validation of data:<ul> <li>Automatic and clear errors when the data is invalid</li> <li>Validation, even for deeply nested JSON objects</li> </ul> </li> <li>Conversion of input data coming from the network, to Python data and types, and reading from:<ul> <li>JSON</li> <li>Path parameters</li> <li>Query parameters</li> <li>Cookies</li> <li>Headers</li> <li>Forms</li> <li>Files</li> </ul> </li> <li>Automatic, interactive API documentation</li> </ul>"},{"location":"#what-next","title":"What next?","text":"<ul> <li>Read the full documentation here - https://pmdevita.github.io/django-shinobi</li> <li>To support this project, please give star it on Github. </li> <li>Share it via Twitter</li> <li>Share your feedback and discuss development on Discord https://discord.gg/ntFTXu7NNv</li> </ul>"},{"location":"differences/","title":"Migrating from Ninja","text":"<p>Shinobi has made a number of changes on top of Ninja. For those migrating from  Ninja to Shinobi, this guide exists to bring you up to speed on the fixes and  and new features.</p>"},{"location":"differences/#changes-from-ninja","title":"Changes from Ninja","text":"<p>Shinobi 1.4.0 is based on Ninja 1.4.3. You can read the changes for Ninja here.</p> <ul> <li>Ninja 1.4.0</li> <li>Ninja 1.4.1</li> <li>Ninja 1.4.2</li> <li>Ninja 1.4.3</li> </ul>"},{"location":"differences/#features","title":"Features","text":""},{"location":"differences/#schema-performance-improvements","title":"Schema Performance Improvements","text":"<p>Shinobi significantly improves the performance of Schema, especially for handling large data payloads.  These improvements are not fully backwards compatible. Depending on the project,  they may work without any changes to your code, but you may need to make changes for  custom <code>model_validator</code> or <code>field_validator</code>s. There may also be issues with FileFields on Pydantic 2.6  and older, so upgrading is recommended.</p> <p>Shinobi has a compatibility mode to retain support for the old Schema behavior. This compatibility mode is  enabled by default in 1.4.0 to help ease the migration, and the full performance improvements are currently opt-in.  You can enable them by setting <code>NINJA_COMPATIBILITY</code> in your settings.py to False.</p> <pre><code># settings.py\nNINJA_COMPATIBILITY = False  # True by default\n</code></pre> <p>The performance improvements can also be configured per Schema by setting <code>_compatibility</code> to <code>True</code> or <code>False</code>.</p> <pre><code>class MySchema(Schema):\n    _compatibility = True\n    ...\n</code></pre> <p>In 1.5.0, the default value for <code>NINJA_COMPATIBILITY</code> will be set to <code>True</code>, making the performance improvements  opt-out. The compatibility behavior will be removed in 1.6.0.</p>"},{"location":"differences/#improved-choices-enum-support","title":"Improved Choices Enum support","text":"<p>Choices and Enums</p> <p>When you use the <code>.choices</code> option on a Model field in Django,</p> <pre><code>class NumberEnum(TextChoices):\n    ONE = \"ONE\", \"One\"\n    TWO = \"TWO\", \"Two\"\n    THREE = \"THREE\", \"Three\"\n\nclass MyModel(models.Model):\n    number = models.CharField(max_length=10, choices=NumberEnum.choices)\n</code></pre> <p>Ninja will not detect the enum and map the type as just a string.</p> <p>Shinobi will automatically detect you are using <code>.choices</code> and carry that over into your ModelSchema. In the  OpenAPI schema, it will appear as an inline enum.</p> <p>In some cases, it may be useful for an enum to be named and reusable between schemas or fields, particularly if you are  working with auto-generated OpenAPI clients. Shinobi can directly carry over a <code>TextChoices</code> or <code>IntegerChoices</code> enum  by adding the <code>ChoicesMixin</code> to it.</p> <p>Info</p> <p><code>ChoicesMixin</code> requires Django 5.0+ and Python 3.11+ Note that <code>choices</code> must be set to <code>NumberEnum</code>, not <code>NumberEnum.choices</code>, as shown in the following example.</p> <pre><code>from ninja.enum import ChoicesMixin\n\nclass NumberEnum(ChoicesMixin, TextChoices):\n    ONE = \"ONE\", \"One\"\n    TWO = \"TWO\", \"Two\"\n    THREE = \"THREE\", \"Three\"\n\nclass MyModel(models.Model):\n    number = models.CharField(max_length=10, choices=NumberEnum)\n</code></pre> <p>This will be published to your OpenAPI schema as a reusable enum.</p>"},{"location":"differences/#bug-fixes","title":"Bug Fixes","text":""},{"location":"differences/#primary-keys-and-blanks-are-now-opt-in-nullable","title":"Primary keys and blanks are now opt-in nullable","text":"<p>A backwards-incompatible change was introduced in Ninja 1.3.0 where <code>ModelSchema</code> now  marks primary key Model Fields and <code>blank</code> Model Fields as nullable. This enforcement is  incorrect, <code>blank</code> is a setting that should be used exclusively by Django forms, and  your primary key should never be null. If you are using your OpenAPI schema to autogenerate  client libraries, this can cause additional issues as they will now need to perform an  unnecessary null check every time they interact with a primary key.</p> <p>This has been reverted to the old behavior. If you still need to mark your primary key  fields as nullable for some reason, you can use <code>fields_optional</code> or set <code>null=True</code>  on the Model Field.</p> <pre><code># Ninja 1.3.0\n\nclass PKNullable(ModelSchema):\n   class Meta:\n       model = MyModel\n       fields = [\"id\"]\n\n# Shinobi 1.4.0\n\nclass PKNullable(ModelSchema):\n    class Meta:\n        model = MyModel\n        fields = [\"id\"]\n        fields_optional = [\"id\"]\n</code></pre>"},{"location":"differences/#foreign-keys-now-work-with-auto-generated-aliases","title":"Foreign keys now work with auto-generated aliases","text":"<p>Automatic Camel Case Aliases</p> <p>Ninja uses Pydantic's alias feature to handle aliasing between a foreign key Field's  normal name (<code>book</code>) and its field name (<code>book_id</code>). However, if you use automatic aliases  such as <code>toCamel</code>, Pydantic will not rewrite the alias for the foreign key field.</p> <p>Shinobi adds a <code>@property</code> field to the Schema so that the normal name can be accessed without  using Pydantic's aliases, freeing it to be used for other manual or automatically generated aliases.</p>"},{"location":"differences/#filefields-now-properly-validate-when-non-null","title":"FileFields now properly validate when non-null","text":"<p>Previously, while FileField and ImageField could show a non-null type, they would always accept  null. This is fixed with the schema improvements and requires Pydantic 2.7. Fixing this created a regression where Pydantic 2.6 and older  always show the field as nullable, so upgrading is recommended.</p>"},{"location":"differences/#build-and-ci-changes","title":"Build and CI Changes","text":""},{"location":"differences/#better-version-compatibility","title":"Better version compatibility","text":"<p>Shinobi now restricts versions of Pydantic to known tested and compatible ones. This should  prevent surprise updates to Pydantic from breaking Shinobi.</p>"},{"location":"differences/#improved-ci-testing","title":"Improved CI testing","text":"<p>Previously, Ninja would only run tests against one specific version of Python, Django, and Pydantic.  Consequentially, in order to hit 100% test coverage, many branches and lines had to be excluded from the  coverage total, which also meant we didn't really have the full picture of line coverage. </p> <p>Shinobi now tests against every supported combination of Python, Django, and Pydantic, and combines  the coverage from them to account for version-specific code. If you're contributing to Shinobi and  open a PR, you'll now also receive a comment detailing which tests passed and failed, and which lines  are still missing in coverage. </p> <p>These changes should make contributing easier and improve the awareness of our testing.</p>"},{"location":"differences/#support","title":"Support","text":"<p>To ease maintenance, Shinobi only supports currently supported version of Django. As of the release of 1.4.0, this includes Django 4.2, 5.1, and 5.2, along with their supported Python and Pydantic versions.</p>"},{"location":"help/","title":"Help / Get Help","text":""},{"location":"help/#do-you-like-django-shinobi","title":"Do you like Django Shinobi?","text":"<p>If you like this project, there is a tiny thing you can do to let us know that we're moving in the right direction.</p> <p>Simply give django-shinobi a star on github </p> <p>or share this URL on social media:  <pre><code>https://pmdevita.github.io/django-shinobi/\n</code></pre> Join the chat on Discord https://discord.gg/ntFTXu7NNv</p>"},{"location":"help/#do-you-want-to-help-us","title":"Do you want to help us?","text":"<p>Pull requests are always welcome.</p> <p>You can inspect our docs for typos and spelling mistakes, and create pull requests or open an issue.</p> <p>If you have any suggestions to improve Django Shinobi, please create them as issues on GitHub.</p>"},{"location":"help/#do-you-need-help","title":"Do you need help?","text":"<p>Do not hesitate. Go to GitHub issues and describe your question or problem.  We'll attempt to address them quickly.</p> <p>Join the chat at our Discord server.</p>"},{"location":"motivation/","title":"Motivation","text":"<p>Quote</p> <p>Django Ninja looks basically the same as FastAPI, so why not just use FastAPI?</p> <p>Indeed, Django Ninja is heavily inspired by FastAPI (developed by Sebasti\u00e1n Ram\u00edrez)</p> <p>That said, there are few issues when it comes to getting FastAPI and Django to work together properly:</p> <p>1) FastAPI declares to be ORM agnostic (meaning you can use it with SQLAlchemy or the Django ORM), but in reality the Django ORM is not yet ready for async use (it may be in version 4.0 or 4.1), and if you use it in sync mode, you can have a closed connection issue which you will have to overcome with a lot of effort.</p> <p>2) The dependency injection with arguments makes your code too verbose when you rely on authentication and database sessions in your operations (which for some projects is about 99% of all operations).</p> <pre><code>...\n\napp = FastAPI()\n\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    user = decode(token)\n    if not user:\n        raise HTTPException(...)\n    return user\n\n\n@app.get(\"/task/{task_id}\", response_model=Task)\ndef read_user(\n        task_id: int,\n        db: Session = Depends(get_db), \n        current_user: User = Depends(get_current_user),\n    ):\n        ... use db with current_user ....\n</code></pre> <p>3) Since the word <code>model</code> in Django is \"reserved\" for use by the ORM, it becomes very confusing when you mix the Django ORM with Pydantic/FastAPI model naming conventions. </p>"},{"location":"motivation/#django-ninja","title":"Django Ninja","text":"<p>Django Ninja addresses all those issues, and integrates very well with Django (ORM, urls, views, auth and more)</p> <p>Working at Code-on a Django webdesign webedevelopment studio I get all sorts of challenges and to solve these I started Django-Ninja in 2020.</p> <p>Note: Django Ninja is a production ready project - my estimation is at this time already 100+ companies using it in production and 500 new developers joining every month. </p> <p>Some companies are already looking for developers with django ninja experience.</p>"},{"location":"motivation/#main-features","title":"Main Features","text":"<p>1) Since you can have multiple Django Ninja API instances - you can run multiple API versions inside one Django project.</p> <pre><code>api_v1 = NinjaAPI(version='1.0', auth=token_auth)\n...\napi_v2 = NinjaAPI(version='2.0', auth=token_auth)\n...\napi_private = NinjaAPI(auth=session_auth, urls_namespace='private_api')\n...\n\n\nurlpatterns = [\n    ...\n    path('api/v1/', api_v1.urls),\n    path('api/v2/', api_v2.urls),\n    path('internal-api/', api_private.urls),\n]\n</code></pre> <p>2) The Django Ninja 'Schema' class is integrated with the ORM, so you can serialize querysets or ORM objects:</p> <p><pre><code>@api.get(\"/tasks\", response=List[TaskSchema])\ndef tasks(request):\n    return Task.objects.all()\n\n\n@api.get(\"/tasks\", response=TaskSchema)\ndef tasks_details(request):\n    task = Task.objects.first()\n    return task\n</code></pre> 3) Create Schema's from Django Models.</p> <p>4) Instead of dependency arguments, Django Ninja uses <code>request</code> instance attributes (in the same way as regular Django views) - more detail at Authentication.</p>"},{"location":"releases/","title":"Release Notes","text":"<p>Follow and subscribe for new releases on GitHub:</p> <p>https://github.com/pmdevita/django-shinobi/releases</p>"},{"location":"whatsnew_v1/","title":"Welcome to Django Shinobi 1.0","text":"<p>To get started install latest version with <pre><code>pip install -U django-shinobi\n</code></pre></p> <p>django-shinobi v1 is compatible with Python 3.7 and above.</p> <p>Django Shinobi series 0.x is still supported but will receive only security updates and critical bug fixes</p>"},{"location":"whatsnew_v1/#whats-new-in-django-ninja-10","title":"What's new in Django Ninja 1.0","text":""},{"location":"whatsnew_v1/#support-for-pydantic2","title":"Support for Pydantic2","text":"<p>Pydantic version 2 is re-written in Rust and includes a lot of improvements and features like:</p> <ul> <li>Safer types.</li> <li>Better extensibility.</li> <li>Better performance </li> </ul> <p>By our tests average project can gain some 10% performance increase on average, while some edge parsing/serializing cases can give you 4x boost.</p> <p>On the other hand it introduces breaking changes and pydantic 1 and 2 are not very compatible - but we tried or best to make this transition easy as possible. So if you used 'Schema' class migration to ninja v1 should be easy. Otherwise follow pydantic migration guide</p> <p>Some features that are made possible with pydantic2</p>"},{"location":"whatsnew_v1/#pydantic-context","title":"pydantic context","text":"<p>Pydantic now supports context during validation and serialization and Django ninja passes \"request\" object during request and response work</p> <pre><code>class Payload(Schema):\n    id: int\n    name: str\n    request_path: str\n\n    @staticmethod\n    def resolve_request_path(data, context):\n        request = context[\"request\"]\n        return request.get_full_path()\n</code></pre> <p>During response a \"response_code\" is also passed to context</p>"},{"location":"whatsnew_v1/#schemameta","title":"Schema.Meta","text":"<p>Pydantic now deprecates BaseModel.Config class.  But to keep things consistent with all other django parts we introduce \"Meta\" class for ModelSchema - which works in a similar way as django's ModelForms:</p> <pre><code>class TxItem(ModelSchema):\n    class Meta:\n        model = Transaction\n        fields = [\"id\", \"account\", \"amount\", \"timestamp\"]\n</code></pre> <p>(The \"Config\" class is still supported, but deprecated)</p>"},{"location":"whatsnew_v1/#shorter-cleaner-parameters-syntax","title":"Shorter / cleaner parameters syntax","text":"<pre><code>@api.post('/some')\ndef some_form(request, username: Form[str], password: Form[str]):\n    return True\n</code></pre> <p>instead of</p> <pre><code>@api.post('/some')\ndef some_form(request, username: str = Form(...), password: str = Form(...)):\n    return True\n</code></pre> <p>or </p> <pre><code>@api.post('/some')\ndef some_form(request, data: Form[AuthSchema]):\n    return True\n</code></pre> <p>instead of</p> <pre><code>@api.post('/some')\ndef some_form(request, data: AuthSchema = Form(...)):\n    return True\n</code></pre> <p>with all the autocompletion in editors</p> <p>On the other hand the old syntax is still supported so you can easily port your project to a newer django-ninja version without much haste </p>"},{"location":"whatsnew_v1/#annotated","title":"+ Annotated","text":"<p>typing.Annotated is also supported:</p> <pre><code>@api.get(\"/annotated\")\ndef annotated(request, data: Annotated[SomeData, Form()]):\n    return {\"data\": data.dict()}\n</code></pre>"},{"location":"whatsnew_v1/#async-auth-support","title":"Async auth support","text":"<p>The async authenticators are finally supported. All you have to do is just add <code>async</code> to your <code>authenticate</code> method:</p> <pre><code>class Auth(HttpBearer):\n    async def authenticate(self, request, token):\n        await asyncio.sleep(1)\n        if token == \"secret\":\n            return token\n</code></pre>"},{"location":"whatsnew_v1/#changed-csrf-behavior","title":"Changed CSRF Behavior","text":"<p><code>csrf=True</code> requirement is no longer required if you use cookie based authentication. Instead CSRF protection is enabled automatically. This also allow you to  mix csrf-protected authenticators and other methods that does not require cookies:</p> <pre><code>api = NinjaAPI(auth=[django_auth, Auth()])\n</code></pre>"},{"location":"whatsnew_v1/#docs","title":"Docs","text":"<p>Doc viewer are now configurable and plugable. By default django ninja comes with Swagger and Redoc:</p> <pre><code>from ninja import NinjaAPI, Redoc, Swagger\n\n\n# use redoc\napi = NinjaAPI(docs=Redoc()))\n\n# use swagger:\napi = NinjaAPI(docs=Swagger())\n\n# set configuration for swagger:\napi = NinjaAPI(docs=Swagger({\"persistAuthorization\": True}))\n</code></pre> <p>Users now able to create custom docs viewer by inheriting <code>DocsBase</code> class</p>"},{"location":"whatsnew_v1/#router","title":"Router","text":"<p>add_router supports string paths:</p> <pre><code>api = NinjaAPI()\n\n\napi.add_router('/app1', 'myproject.app1.router')\napi.add_router('/app2', 'myproject.app2.router')\napi.add_router('/app3', 'myproject.app3.router')\napi.add_router('/app4', 'myproject.app4.router')\napi.add_router('/app5', 'myproject.app5.router')\n</code></pre>"},{"location":"whatsnew_v1/#decorators","title":"Decorators","text":"<p>When django ninja decorates a view with .get/.post etc. - it wraps the result of the function (which in most cases are not HttpResponse - but some serializable object) so it's not really possible to use some built-in or 3rd-party decorators like:</p> <p><pre><code>from django.views.decorators.cache import cache_page\n\n@api.get(\"/test\")\n@cache_page(5) # &lt;----- will not work\ndef test_view(request):\n    return {\"some\": \"Complex data\"}\n</code></pre> This example does not work.</p> <p>Now django ninja introduces a decorator decorate_view that allows inject decorators that work with http response:</p> <pre><code>from ninja.decorators import decorate_view\n\n@api.get(\"/test\")\n@decorate_view(cache_page(5))\ndef test_view(request):\n    return str(datetime.now())\n</code></pre>"},{"location":"whatsnew_v1/#paginations","title":"Paginations","text":"<p><code>paginate_queryset</code> method now takes <code>request</code> object</p>"},{"location":"whatsnew_v1/#backwards-incompatible-stuff","title":"Backwards incompatible stuff","text":"<ul> <li>resolve_xxx(self, ...) - support resolve with (self) is dropped in favor of pydantic build-in functionality</li> <li>pydantic v1 is no longer supported</li> <li>python 3.6 is no longer supported</li> </ul> <p>BTW - if you like this project and still did not give it a github start - please do so </p>"},{"location":"guides/api-docs/","title":"API Docs","text":""},{"location":"guides/api-docs/#openapi-docs","title":"OpenAPI docs","text":"<p>Once you configured your Ninja API and started runserver -  go to http://127.0.0.1:8000/api/docs</p> <p>You will see the automatic, interactive API documentation (provided by the OpenAPI / Swagger UI</p>"},{"location":"guides/api-docs/#cdn-vs-staticfiles","title":"CDN vs staticfiles","text":"<p>You are not required to put django ninja to <code>INSTALLED_APPS</code>. In that case the interactive UI is hosted by CDN.</p> <p>To host docs (Js/css) from your own server - just put \"ninja\" to INSTALLED_APPS - in that case standard django staticfiles mechanics will host it.</p>"},{"location":"guides/api-docs/#switch-to-redoc","title":"Switch to Redoc","text":"<pre><code>from ninja import Redoc\n\napi = NinjaAPI(docs=Redoc())\n</code></pre> <p>Then you will see the alternative automatic documentation (provided by Redoc).</p>"},{"location":"guides/api-docs/#changing-docs-display-settings","title":"Changing docs display settings","text":"<p>To set some custom settings for Swagger or Redocs you can use <code>settings</code> param on the docs class</p> <pre><code>from ninja import Redoc, Swagger\n\napi = NinjaAPI(docs=Swagger(settings={\"persistAuthorization\": True}))\n...\napi = NinjaAPI(docs=Redoc(settings={\"disableSearch\": True}))\n</code></pre> <p>Settings reference:</p> <ul> <li>Swagger configuration</li> <li>Redoc configuration</li> </ul>"},{"location":"guides/api-docs/#hiding-docs","title":"Hiding docs","text":"<p>In case you do not need to display interactive documentation - set <code>docs_url</code> argument to <code>None</code></p> <pre><code>api = NinjaAPI(docs_url=None)\n</code></pre>"},{"location":"guides/api-docs/#protecting-docs","title":"Protecting docs","text":"<p>To protect docs with authentication (or decorate for some other use case) use <code>docs_decorator</code> argument:</p> <pre><code>from django.contrib.admin.views.decorators import staff_member_required\n\napi = NinjaAPI(docs_decorator=staff_member_required)\n</code></pre>"},{"location":"guides/api-docs/#extending-openapi-spec-with-custom-attributes","title":"Extending OpenAPI Spec with custom attributes","text":"<p>You can extend OpenAPI spec with custom attributes, for example to add <code>termsOfService</code></p> <pre><code>api = NinjaAPI(\n   openapi_extra={\n       \"info\": {\n           \"termsOfService\": \"https://example.com/terms/\",\n       }\n   },\n   title=\"Demo API\",\n   description=\"This is a demo API with dynamic OpenAPI info section\"\n)\n</code></pre>"},{"location":"guides/api-docs/#resolving-the-docs-url","title":"Resolving the doc's url","text":"<p>The url for the api's documentation view can be reversed by referencing the view's name <code>openapi-view</code>.</p> <p>In Python code, for example: <pre><code>from django.urls import reverse\n\nreverse('api-1.0.0:openapi-view')\n\n&gt;&gt;&gt; '/api/docs'\n</code></pre></p> <p>In a Django template, for example: <pre><code>&lt;a href=\"{% url 'api-1.0.0:openapi-view' %}\"&gt;API Docs&lt;/a&gt;\n\n&lt;a href=\"/api/docs\"&gt;API Docs&lt;/a&gt;\n</code></pre></p>"},{"location":"guides/api-docs/#creating-custom-docs-viewer","title":"Creating custom docs viewer","text":"<p>To create your own view for OpenAPI - create a class inherited from DocsBase and overwrite <code>render_page</code> method:</p> <pre><code>form ninja.openapi.docs import DocsBase\n\nclass MyDocsViewer(DocsBase)\n    def render_page(self, request, api):\n        ... # return http response\n\n...\n\napi = NinjaAPI(docs=MyDocsViewer())\n</code></pre>"},{"location":"guides/async-support/","title":"Async support","text":""},{"location":"guides/async-support/#intro","title":"Intro","text":"<p>Since version 3.1, Django comes with async views support. This allows you run efficient concurrent views that are network and/or IO bound.</p> <pre><code>pip install Django&gt;=3.1 django-shinobi\n</code></pre> <p>Async views work more efficiently when it comes to:</p> <ul> <li>calling external APIs over the network</li> <li>executing/waiting for database queries</li> <li>reading/writing from/to disk drives</li> </ul> <p>Django Ninja takes full advantage of async views and makes it very easy to work with them.</p>"},{"location":"guides/async-support/#quick-example","title":"Quick example","text":""},{"location":"guides/async-support/#code","title":"Code","text":"<p>Let's take an example.  We have an API operation that does some work (currently just sleeps for provided number of seconds) and returns a word:</p> <pre><code>import time\n\n@api.get(\"/say-after\")\ndef say_after(request, delay: int, word: str):\n    time.sleep(delay)\n    return {\"saying\": word}\n</code></pre> <p>To make this code asynchronous, all you have to do is add the <code>async</code> keyword to a function (and use async aware libraries for work processing - in our case we will replace the stdlib <code>sleep</code> with <code>asyncio.sleep</code>):</p> <pre><code>import asyncio\n\n@api.get(\"/say-after\")\nasync def say_after(request, delay: int, word: str):\n    await asyncio.sleep(delay)\n    return {\"saying\": word}\n</code></pre>"},{"location":"guides/async-support/#run","title":"Run","text":"<p>To run this code you need an ASGI server like Uvicorn or Daphne. Let's use Uvicorn for, example:</p> <p>To install Uvicorn, use:</p> <pre><code>pip install uvicorn\n</code></pre> <p>Then start the server:</p> <pre><code>uvicorn your_project.asgi:application --reload\n</code></pre> <p> Note: replace <code>your_project</code> with your project package name <code>--reload</code> flag used to automatically reload server if you do any changes to the code (do not use on production) </p> <p>Note</p> <p>You can run async views with <code>manage.py runserver</code>, but it does not work well with some libraries, so at this time (July 2020) it is recommended to use ASGI servers like Uvicorn or Daphne.</p>"},{"location":"guides/async-support/#test","title":"Test","text":"<p>Go to your browser and open http://127.0.0.1:8000/api/say-after?delay=3&amp;word=hello (delay=3) After a 3-second wait you should see the \"hello\" message.</p> <p>Now let's flood this operation with 100 parallel requests:</p> <pre><code>ab -c 100 -n 100 \"http://127.0.0.1:8000/api/say-after?delay=3&amp;word=hello\"\n</code></pre> <p>which will result in something like this:</p> <pre><code>Connection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    1   1.1      1       4\nProcessing:  3008 3063  16.2   3069    3082\nWaiting:     3008 3062  15.7   3068    3079\nTotal:       3008 3065  16.3   3070    3083\n\nPercentage of the requests served within a certain time (ms)\n  50%   3070\n  66%   3072\n  75%   3075\n  80%   3076\n  90%   3081\n  95%   3082\n  98%   3083\n  99%   3083\n 100%   3083 (longest request)\n</code></pre> <p>Based on the numbers, our service was able to handle each of the 100 concurrent requests with just a little overhead.</p> <p>To achieve the same concurrency with WSGI and sync operations you would need to spin up about 10 workers with 10 threads each!</p>"},{"location":"guides/async-support/#mixing-sync-and-async-operations","title":"Mixing sync and async operations","text":"<p>Keep in mind that you can use both sync and async operations in your project, and Django Ninja will route it automatically:</p> <pre><code>@api.get(\"/say-sync\")\ndef say_after_sync(request, delay: int, word: str):\n    time.sleep(delay)\n    return {\"saying\": word}\n\n@api.get(\"/say-async\")\nasync def say_after_async(request, delay: int, word: str):\n    await asyncio.sleep(delay)\n    return {\"saying\": word}\n</code></pre>"},{"location":"guides/async-support/#elasticsearch-example","title":"Elasticsearch example","text":"<p>Let's take a real world use case. For this example, let's use the latest version of Elasticsearch that now comes with async support:</p> <pre><code>pip install elasticsearch&gt;=7.8.0\n</code></pre> <p>And now instead of the <code>Elasticsearch</code> class, use the <code>AsyncElasticsearch</code> class and <code>await</code> the results:</p> <pre><code>from ninja import NinjaAPI\nfrom elasticsearch import AsyncElasticsearch\n\n\napi = NinjaAPI()\n\nes = AsyncElasticsearch()\n\n\n@api.get(\"/search\")\nasync def search(request, q: str):\n    resp = await es.search(\n        index=\"documents\", \n        body={\"query\": {\"query_string\": {\"query\": q}}},\n        size=20,\n    )\n    return resp[\"hits\"]\n</code></pre>"},{"location":"guides/async-support/#using-orm","title":"Using ORM","text":"<p>Currently, certain key parts of Django are not able to operate safely in an async environment, as they have global state that is not coroutine-aware. These parts of Django are classified as \u201casync-unsafe\u201d, and are protected from execution in an async environment. The ORM is the main example, but there are other parts that are also protected in this way.</p> <p>Learn more about async safety here in the official Django docs.</p> <p>So, if you do this:</p> <pre><code>@api.get(\"/blog/{post_id}\")\nasync def search(request, post_id: int):\n    blog = Blog.objects.get(pk=post_id)\n    ...\n</code></pre> <p>it throws an error. Until the async ORM is implemented, you can use the <code>sync_to_async()</code> adapter:</p> <pre><code>from asgiref.sync import sync_to_async\n\n@sync_to_async\ndef get_blog(post_id):\n    return Blog.objects.get(pk=post_id)\n\n@api.get(\"/blog/{post_id}\")\nasync def search(request, post_id: int):\n    blog = await get_blog(post_id)\n    ...\n</code></pre> <p>or even shorter:</p> <pre><code>@api.get(\"/blog/{post_id}\")\nasync def search(request, post_id: int):\n    blog = await sync_to_async(Blog.objects.get)(pk=post_id)\n    ...\n</code></pre> <p>There is a common GOTCHA: Django querysets are lazily evaluated (database query happens only when you start iterating), so this will not work:</p> <pre><code>all_blogs = await sync_to_async(Blog.objects.all)()\n# it will throw an error later when you try to iterate over all_blogs\n...\n</code></pre> <p>Instead, use evaluation (with <code>list</code>):</p> <pre><code>all_blogs = await sync_to_async(list)(Blog.objects.all())\n...\n</code></pre> <p>Since Django version 4.1, Django comes with asynchronous versions of ORM operations. These eliminate the need to use <code>sync_to_async</code> in most cases. The async operations have the same names as their sync counterparts but are prepended with a. So using the example above, you can rewrite it as:</p> <pre><code>@api.get(\"/blog/{post_id}\")\nasync def search(request, post_id: int):\n    blog = await Blog.objects.aget(pk=post_id)\n    ...\n</code></pre> <p>When working with querysets, use <code>async for</code> paired with list comprehension:</p> <pre><code>all_blogs = [blog async for blog in Blog.objects.all()]\n...\n</code></pre> <p>Learn more about the async ORM interface in the official Django docs.</p>"},{"location":"guides/authentication/","title":"Authentication","text":""},{"location":"guides/authentication/#intro","title":"Intro","text":"<p>Django Ninja provides several tools to help you deal with authentication and authorization easily, rapidly, in a standard way, and without having to study and learn all the security specifications.</p> <p>The core concept is that when you describe an API operation, you can define an authentication object.</p> <pre><code>from ninja import NinjaAPI\nfrom ninja.security import django_auth\n\napi = NinjaAPI(csrf=True)\n\n\n@api.get(\"/pets\", auth=django_auth)\ndef pets(request):\n    return f\"Authenticated user {request.auth}\"\n</code></pre> <p>In this example, the client will only be able to call the <code>pets</code> method if it uses Django session authentication (the default is cookie based), otherwise an HTTP-401 error will be returned.</p> <p>If you need to authorize only a superuser, you can use <code>from ninja.security import django_auth_superuser</code> instead.</p>"},{"location":"guides/authentication/#automatic-openapi-schema","title":"Automatic OpenAPI schema","text":"<p>Here's an example where the client, in order to authenticate, needs to pass a header:</p> <p><code>Authorization: Bearer supersecret</code></p> <pre><code>from ninja.security import HttpBearer\n\n\nclass AuthBearer(HttpBearer):\n    def authenticate(self, request, token):\n        if token == \"supersecret\":\n            return token\n\n\n@api.get(\"/bearer\", auth=AuthBearer())\ndef bearer(request):\n    return {\"token\": request.auth}\n</code></pre> <p>Now go to the docs at http://localhost:8000/api/docs.</p> <p></p> <p>Now, when you click the Authorize button, you will get a prompt to input your authentication token.</p> <p></p> <p>When you do test calls, the Authorization header will be passed for every request.</p>"},{"location":"guides/authentication/#global-authentication","title":"Global authentication","text":"<p>In case you need to secure all methods of your API, you can pass the <code>auth</code> argument to the <code>NinjaAPI</code> constructor:</p> <pre><code>from ninja import NinjaAPI, Form\nfrom ninja.security import HttpBearer\n\n\nclass GlobalAuth(HttpBearer):\n    def authenticate(self, request, token):\n        if token == \"supersecret\":\n            return token\n\n\napi = NinjaAPI(auth=GlobalAuth())\n\n# @api.get(...)\n# def ...\n\n# @api.post(...)\n# def ...\n</code></pre> <p>And, if you need to overrule some of those methods, you can do that on the operation level again by passing the <code>auth</code> argument. In this example, authentication will be disabled for the <code>/token</code> operation:</p> <pre><code>from ninja import NinjaAPI, Form\nfrom ninja.security import HttpBearer\n\n\nclass GlobalAuth(HttpBearer):\n    def authenticate(self, request, token):\n        if token == \"supersecret\":\n            return token\n\n\napi = NinjaAPI(auth=GlobalAuth())\n\n# @api.get(...)\n# def ...\n# @api.post(...)\n# def ...\n\n\n@api.post(\"/token\", auth=None)  # &lt; overriding global auth\ndef get_token(request, username: str = Form(...), password: str = Form(...)):\n    if username == \"admin\" and password == \"giraffethinnknslong\":\n        return {\"token\": \"supersecret\"}\n</code></pre>"},{"location":"guides/authentication/#available-auth-options","title":"Available auth options","text":""},{"location":"guides/authentication/#custom-function","title":"Custom function","text":"<p>The \"<code>auth=</code>\" argument accepts any Callable object. NinjaAPI passes authentication only if the callable object returns a value that can be converted to boolean <code>True</code>. This return value will be assigned to the <code>request.auth</code> attribute.</p> <pre><code>def ip_whitelist(request):\n    if request.META[\"REMOTE_ADDR\"] == \"8.8.8.8\":\n        return \"8.8.8.8\"\n\n\n@api.get(\"/ipwhitelist\", auth=ip_whitelist)\ndef ipwhitelist(request):\n    return f\"Authenticated client, IP = {request.auth}\"\n</code></pre>"},{"location":"guides/authentication/#api-key","title":"API Key","text":"<p>Some API's use API keys for authorization. An API key is a token that a client provides when making API calls to identify itself. The key can be sent in the query string: <pre><code>GET /something?api_key=abcdef12345\n</code></pre></p> <p>or as a request header:</p> <pre><code>GET /something HTTP/1.1\nX-API-Key: abcdef12345\n</code></pre> <p>or as a cookie:</p> <pre><code>GET /something HTTP/1.1\nCookie: X-API-KEY=abcdef12345\n</code></pre> <p>Django Ninja comes with built-in classes to help you handle these cases.</p>"},{"location":"guides/authentication/#in-query","title":"in Query","text":"<pre><code>from ninja.security import APIKeyQuery\nfrom someapp.models import Client\n\n\nclass ApiKey(APIKeyQuery):\n    param_name = \"api_key\"\n\n    def authenticate(self, request, key):\n        try:\n            return Client.objects.get(key=key)\n        except Client.DoesNotExist:\n            pass\n\n\napi_key = ApiKey()\n\n\n@api.get(\"/apikey\", auth=api_key)\ndef apikey(request):\n    assert isinstance(request.auth, Client)\n    return f\"Hello {request.auth}\"\n</code></pre> <p>In this example we take a token from <code>GET['api_key']</code> and find a <code>Client</code> in the database that corresponds to this key. The Client instance will be set to the <code>request.auth</code> attribute.</p> <p>Note: <code>param_name</code> is the name of the GET parameter that will be checked for. If not set, the default of \"<code>key</code>\" will be used.</p>"},{"location":"guides/authentication/#in-header","title":"in Header","text":"<pre><code>from ninja.security import APIKeyHeader\n\n\nclass ApiKey(APIKeyHeader):\n    param_name = \"X-API-Key\"\n\n    def authenticate(self, request, key):\n        if key == \"supersecret\":\n            return key\n\n\nheader_key = ApiKey()\n\n\n@api.get(\"/headerkey\", auth=header_key)\ndef apikey(request):\n    return f\"Token = {request.auth}\"\n</code></pre>"},{"location":"guides/authentication/#in-cookie","title":"in Cookie","text":"<pre><code>from ninja.security import APIKeyCookie\n\n\nclass CookieKey(APIKeyCookie):\n    def authenticate(self, request, key):\n        if key == \"supersecret\":\n            return key\n\n\ncookie_key = CookieKey()\n\n\n@api.get(\"/cookiekey\", auth=cookie_key)\ndef apikey(request):\n    return f\"Token = {request.auth}\"\n</code></pre>"},{"location":"guides/authentication/#http-bearer","title":"HTTP Bearer","text":"<pre><code>from ninja.security import HttpBearer\n\n\nclass AuthBearer(HttpBearer):\n    def authenticate(self, request, token):\n        if token == \"supersecret\":\n            return token\n\n\n@api.get(\"/bearer\", auth=AuthBearer())\ndef bearer(request):\n    return {\"token\": request.auth}\n</code></pre>"},{"location":"guides/authentication/#http-basic-auth","title":"HTTP Basic Auth","text":"<pre><code>from ninja.security import HttpBasicAuth\n\n\nclass BasicAuth(HttpBasicAuth):\n    def authenticate(self, request, username, password):\n        if username == \"admin\" and password == \"secret\":\n            return username\n\n\n@api.get(\"/basic\", auth=BasicAuth())\ndef basic(request):\n    return {\"httpuser\": request.auth}\n</code></pre>"},{"location":"guides/authentication/#multiple-authenticators","title":"Multiple authenticators","text":"<p>The <code>auth</code> argument also allows you to pass multiple authenticators:</p> <pre><code>from ninja.security import APIKeyQuery, APIKeyHeader\n\n\nclass AuthCheck:\n    def authenticate(self, request, key):\n        if key == \"supersecret\":\n            return key\n\n\nclass QueryKey(AuthCheck, APIKeyQuery):\n    pass\n\n\nclass HeaderKey(AuthCheck, APIKeyHeader):\n    pass\n\n\n@api.get(\"/multiple\", auth=[QueryKey(), HeaderKey()])\ndef multiple(request):\n    return f\"Token = {request.auth}\"\n</code></pre> <p>In this case Django Ninja will first check the API key <code>GET</code>, and if not set or invalid will check the <code>header</code> key. If both are invalid, it will raise an authentication error to the response.</p>"},{"location":"guides/authentication/#router-authentication","title":"Router authentication","text":"<p>Use <code>auth</code> argument on Router to apply authenticator to all operations declared in it:</p> <pre><code>api.add_router(\"/events/\", events_router, auth=BasicAuth())\n</code></pre> <p>or using router constructor <pre><code>router = Router(auth=BasicAuth())\n</code></pre></p> <p>This overrides any API level authentication. To allow router operations to not use the API-level authentication by default, you can explicitly set the router's <code>auth=None</code>.</p>"},{"location":"guides/authentication/#custom-exceptions","title":"Custom exceptions","text":"<p>Raising an exception that has an exception handler will return the response from that handler in the same way an operation would:</p> <pre><code>from ninja import NinjaAPI\nfrom ninja.security import HttpBearer\n\napi = NinjaAPI()\n\nclass InvalidToken(Exception):\n    pass\n\n@api.exception_handler(InvalidToken)\ndef on_invalid_token(request, exc):\n    return api.create_response(request, {\"detail\": \"Invalid token supplied\"}, status=401)\n\nclass AuthBearer(HttpBearer):\n    def authenticate(self, request, token):\n        if token == \"supersecret\":\n            return token\n        raise InvalidToken\n\n\n@api.get(\"/bearer\", auth=AuthBearer())\ndef bearer(request):\n    return {\"token\": request.auth}\n</code></pre>"},{"location":"guides/authentication/#async-authentication","title":"Async authentication","text":"<p>Django Ninja has basic support for asynchronous authentication. While the default authentication classes are not async-compatible, you can still define your custom asynchronous authentication callables and pass them in using <code>auth</code>.</p> <pre><code>async def async_auth(request):\n    ...\n\n\n@api.get(\"/pets\", auth=async_auth)\ndef pets(request):\n    ...\n</code></pre> <p>See Handling errors for more information.</p>"},{"location":"guides/errors/","title":"Handling errors","text":"<p>Django Ninja allows you to install custom exception handlers to deal with how you return responses when errors or handled exceptions occur.</p>"},{"location":"guides/errors/#custom-exception-handlers","title":"Custom exception handlers","text":"<p>Let's say you are making API that depends on some external service that is designed to be unavailable at some moments. Instead of throwing default 500 error upon exception - you can handle the error and give some friendly response back to the client (to come back later)</p> <p>To achieve that you need:</p> <ol> <li>create some exception (or use existing one)</li> <li>use api.exception_handler decorator</li> </ol> <p>Example:</p> <pre><code>api = NinjaAPI()\n\nclass ServiceUnavailableError(Exception):\n    pass\n\n\n# initializing handler\n\n@api.exception_handler(ServiceUnavailableError)\ndef service_unavailable(request, exc):\n    return api.create_response(\n        request,\n        {\"message\": \"Please retry later\"},\n        status=503,\n    )\n\n\n# some logic that throws exception\n\n@api.get(\"/service\")\ndef some_operation(request):\n    if random.choice([True, False]):\n        raise ServiceUnavailableError()\n    return {\"message\": \"Hello\"}\n</code></pre> <p>Exception handler function takes 2 arguments:</p> <ul> <li>request - Django http request</li> <li>exc - actual exception</li> </ul> <p>function must return http response</p>"},{"location":"guides/errors/#override-the-default-exception-handlers","title":"Override the default exception handlers","text":"<p>Django Ninja registers default exception handlers for the types shown below. You can register your own handlers with <code>@api.exception_handler</code> to override the default handlers.</p>"},{"location":"guides/errors/#ninjaerrorsauthenticationerror","title":"<code>ninja.errors.AuthenticationError</code>","text":"<p>Raised when authentication data is not valid</p>"},{"location":"guides/errors/#ninjaerrorsauthorizationerror","title":"<code>ninja.errors.AuthorizationError</code>","text":"<p>Raised when authentication data is valid, but doesn't allow you to access the resource</p>"},{"location":"guides/errors/#ninjaerrorsvalidationerror","title":"<code>ninja.errors.ValidationError</code>","text":"<p>Raised when request data does not validate</p>"},{"location":"guides/errors/#ninjaerrorshttperror","title":"<code>ninja.errors.HttpError</code>","text":"<p>Used to throw http error with status code from any place of the code</p>"},{"location":"guides/errors/#djangohttphttp404","title":"<code>django.http.Http404</code>","text":"<p>Django's default 404 exception (can be returned f.e. with <code>get_object_or_404</code>)</p>"},{"location":"guides/errors/#exception","title":"<code>Exception</code>","text":"<p>Any other unhandled exception by application.</p> <p>Default behavior </p> <ul> <li>if <code>settings.DEBUG</code> is <code>True</code> - returns a traceback in plain text (useful when debugging in console or swagger UI)</li> <li>else - default django exception handler mechanism is used (error logging, email to ADMINS)</li> </ul>"},{"location":"guides/errors/#customizing-request-validation-errors","title":"Customizing request validation errors","text":"<p>Requests that fail validation raise <code>ninja.errors.ValidationError</code> (not to be confused with <code>pydantic.ValidationError</code>). <code>ValidationError</code>s have a default exception handler that returns a 422 (Unprocessable Content) JSON response of the form: <pre><code>{\n    \"detail\": [ ... ]\n}\n</code></pre></p> <p>You can change this behavior by overriding the default handler for <code>ValidationError</code>s:</p> <pre><code>from ninja.errors import ValidationError\n...\n\n@api.exception_handler(ValidationError)\ndef validation_errors(request, exc):\n    return HttpResponse(\"Invalid input\", status=422)\n</code></pre> <p>If you need even more control over validation errors (for example, if you need to reference the schema associated with the model that failed validation), you can supply your own <code>validation_error_from_error_contexts</code> in a <code>NinjaAPI</code> subclass:</p> <pre><code>from ninja.errors import ValidationError, ValidationErrorContext\nfrom typing import Any, Dict, List\n\nclass CustomNinjaAPI(NinjaAPI):\n    def validation_error_from_error_contexts(\n        self, error_contexts: List[ValidationErrorContext],\n    ) -&gt; ValidationError:\n        custom_error_infos: List[Dict[str, Any]] = []\n        for context in error_contexts:\n            model = context.model\n            pydantic_schema = model.__pydantic_core_schema__\n            param_source = model.__ninja_param_source__\n            for e in context.pydantic_validation_error.errors(\n                include_url=False, include_context=False, include_input=False\n            ):\n                custom_error_info = {\n                # TODO: use `e`, `param_source`, and `pydantic_schema` as desired\n                }\n                custom_error_infos.append(custom_error_info)\n        return ValidationError(custom_error_infos)\n\napi = CustomNinjaAPI()\n</code></pre> <p>Now each <code>ValidationError</code> raised during request validation will contain data from your <code>validation_error_from_error_contexts</code>.</p>"},{"location":"guides/errors/#throwing-http-responses-with-exceptions","title":"Throwing HTTP responses with exceptions","text":"<p>As an alternative to custom exceptions and writing handlers for it - you can as well throw http exception that will lead to returning a http response with desired code</p> <pre><code>from ninja.errors import HttpError\n\n@api.get(\"/some/resource\")\ndef some_operation(request):\n    if True:\n        raise HttpError(503, \"Service Unavailable. Please retry later.\")\n</code></pre>"},{"location":"guides/routers/","title":"Routers","text":"<p>Real world applications can almost never fit all logic into a single file. </p> <p>Django Ninja comes with an easy way to split your API into multiple modules using Routers.</p> <p>Let's say you have a Django project with a structure like this:</p> <pre><code>\u251c\u2500\u2500 myproject\n\u2502   \u2514\u2500\u2500 settings.py\n\u251c\u2500\u2500 events/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 models.py\n\u251c\u2500\u2500 news/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 models.py\n\u251c\u2500\u2500 blogs/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 models.py\n\u2514\u2500\u2500 manage.py\n</code></pre> <p>To add API's to each of the Django applications, create an <code>api.py</code> module in each app:</p> <pre><code>\u251c\u2500\u2500 myproject\n\u2502   \u2514\u2500\u2500 settings.py\n\u251c\u2500\u2500 events/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 api.py\n\u2502   \u2514\u2500\u2500 models.py\n\u251c\u2500\u2500 news/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 api.py\n\u2502   \u2514\u2500\u2500 models.py\n\u251c\u2500\u2500 blogs/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 api.py\n\u2502   \u2514\u2500\u2500 models.py\n\u2514\u2500\u2500 manage.py\n</code></pre> <p>Now let's add a few operations to <code>events/api.py</code>. The trick is that instead of using the <code>NinjaAPI</code> class, you use the Router class:</p> <pre><code>from ninja import Router\nfrom .models import Event\n\nrouter = Router()\n\n@router.get('/')\ndef list_events(request):\n    return [\n        {\"id\": e.id, \"title\": e.title}\n        for e in Event.objects.all()\n    ]\n\n@router.get('/{event_id}')\ndef event_details(request, event_id: int):\n    event = Event.objects.get(id=event_id)\n    return {\"title\": event.title, \"details\": event.details}\n</code></pre> <p>Then do the same for the <code>news</code> app with <code>news/api.py</code>:</p> <p><pre><code>from ninja import Router\nfrom .models import News\n\nrouter = Router()\n\n@router.get('/')\ndef list_news(request):\n    ...\n\n@router.get('/{news_id}')\ndef news_details(request, news_id: int):\n    ...\n</code></pre> and then also <code>blogs/api.py</code>.</p> <p>Finally, let's group them together. In your top level project folder (next to <code>urls.py</code>), create another <code>api.py</code> file with the main <code>NinjaAPI</code> instance:</p> <pre><code>\u251c\u2500\u2500 myproject\n\u2502   \u251c\u2500\u2500 api.py\n\u2502   \u2514\u2500\u2500 settings.py\n\u251c\u2500\u2500 events/\n\u2502   ...\n\u251c\u2500\u2500 news/\n\u2502   ...\n\u251c\u2500\u2500 blogs/\n\u2502   ...\n</code></pre> <p>It should look like this:</p> <pre><code>from ninja import NinjaAPI\n\napi = NinjaAPI()\n</code></pre> <p>Now we import all the routers from the various apps, and include them into the main API instance:</p> <pre><code>from ninja import NinjaAPI\nfrom events.api import router as events_router\n\napi = NinjaAPI()\n\napi.add_router(\"/events/\", events_router)    # You can add a router as an object\napi.add_router(\"/news/\", \"news.api.router\")  #   or by Python path\napi.add_router(\"/blogs/\", \"blogs.api.router\")\n</code></pre> <p>Now, include <code>api</code> to your urls as usual and open your browser at <code>/api/docs</code>, and you should see all your routers combined into a single API:</p> <p></p>"},{"location":"guides/routers/#router-authentication","title":"Router authentication","text":"<p>Use <code>auth</code> argument to apply authenticator to all operations declared by router:</p> <pre><code>api.add_router(\"/events/\", events_router, auth=BasicAuth())\n</code></pre> <p>or using router constructor <pre><code>router = Router(auth=BasicAuth())\n</code></pre></p>"},{"location":"guides/routers/#router-tags","title":"Router tags","text":"<p>You can use <code>tags</code> argument to apply tags to all operations declared by router:</p> <pre><code>api.add_router(\"/events/\", events_router, tags=[\"events\"])\n</code></pre> <p>or using router constructor <pre><code>router = Router(tags=[\"events\"])\n</code></pre></p>"},{"location":"guides/routers/#nested-routers","title":"Nested routers","text":"<p>There are also times when you need to split your logic up even more. Django Ninja makes it possible to include a router into another router as many times as you like, and finally include the top level router into the main <code>api</code> instance.</p> <p>Basically, what that means is that you have <code>add_router</code> both on the <code>api</code> instance and on the <code>router</code> instance:</p> <pre><code>from django.contrib import admin\nfrom django.urls import path\nfrom ninja import NinjaAPI, Router\n\napi = NinjaAPI()\n\nfirst_router = Router()\nsecond_router = Router()\nthird_router = Router()\n\n\n@api.get(\"/add\")\ndef add(request, a: int, b: int):\n    return {\"result\": a + b}\n\n\n@first_router.get(\"/add\")\ndef add(request, a: int, b: int):\n    return {\"result\": a + b}\n\n\n@second_router.get(\"/add\")\ndef add(request, a: int, b: int):\n    return {\"result\": a + b}\n\n\n@third_router.get(\"/add\")\ndef add(request, a: int, b: int):\n    return {\"result\": a + b}\n\n\nsecond_router.add_router(\"l3\", third_router)\nfirst_router.add_router(\"l2\", second_router)\napi.add_router(\"l1\", first_router)\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"api/\", api.urls),\n]\n</code></pre> <p>Now you have the following endpoints:</p> <pre><code>/api/add\n/api/l1/add\n/api/l1/l2/add\n/api/l1/l2/l3/add\n</code></pre> <p>Great! Now go have a look at the automatically generated docs:</p> <p></p>"},{"location":"guides/routers/#nested-url-parameters","title":"Nested url parameters","text":"<p>You can also use url parameters in nested routers by adding <code>= Path(...)</code> to the function parameters:</p> <pre><code>from django.contrib import admin\nfrom django.urls import path\nfrom ninja import NinjaAPI, Path, Router\n\napi = NinjaAPI()\nrouter = Router()\n\n@api.get(\"/add/{a}/{b}\")\ndef add(request, a: int, b: int):\n    return {\"result\": a + b}\n\n@router.get(\"/multiply/{c}\")\ndef multiply(request, c: int, a: int = Path(...), b: int = Path(...)):\n    return {\"result\": (a + b) * c}\n\napi.add_router(\"add/{a}/{b}\", router)\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"api/\", api.urls),\n]\n</code></pre> <p>This will generate the following endpoints:</p> <pre><code>/api/add/{a}/{b}\n/api/add/{a}/{b}/multiply/{c}\n</code></pre>"},{"location":"guides/testing/","title":"Testing","text":"<p>Django Ninja is fully compatible with standard django test client , but also provides a test client to make it easy to test just APIs without middleware/url-resolver layer making tests run faster.</p> <p>To test the following API: <pre><code>from ninja import NinjaAPI, Schema\n\napi = NinjaAPI()\nrouter = Router()\n\nclass HelloResponse(Schema):\n    msg: str\n\n@router.get(\"/hello\", response=HelloResponse)\ndef hello(request):\n    return {\"msg\": \"Hello World\"}\n\napi.add_router(\"\", router)\n</code></pre></p> <p>You can use the Django test class: <pre><code>from django.test import TestCase\nfrom ninja.testing import TestClient\n\nclass HelloTest(TestCase):\n    def test_hello(self):\n        # don't forget to import router from code above\n        client = TestClient(router)\n        response = client.get(\"/hello\")\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.json(), {\"msg\": \"Hello World\"})\n</code></pre></p> <p>It is also possible to access the deserialized data using the <code>data</code> property: <pre><code>    self.assertEqual(response.data, {\"msg\": \"Hello World\"})\n</code></pre></p>"},{"location":"guides/testing/#attributes","title":"Attributes","text":"<p>Arbitrary attributes can be added to the request object by passing keyword arguments to the client request methods: <pre><code>class HelloTest(TestCase):\n    def test_hello(self):\n        client = TestClient(router)\n        # request.company_id will now be set within the view\n        response = client.get(\"/hello\", company_id=1)\n</code></pre></p>"},{"location":"guides/testing/#headers","title":"Headers","text":"<p>It is also possible to specify headers, both from the TestCase instantiation and the actual request: <pre><code>    client = TestClient(router, headers={\"A\": \"a\", \"B\": \"b\"})\n    # The request will be made with {\"A\": \"na\", \"B\": \"b\", \"C\": \"nc\"} headers\n    response = client.get(\"/test-headers\", headers={\"A\": \"na\", \"C\": \"nc\"})\n</code></pre></p>"},{"location":"guides/testing/#cookies","title":"Cookies","text":"<p>It is also possible to specify cookies, both from the TestCase instantiation and the actual request: <pre><code>    client = TestClient(router, COOKIES={\"A\": \"a\", \"B\": \"b\"})\n    # The request will be made with {\"A\": \"na\", \"B\": \"b\", \"C\": \"nc\"} cookies\n    response = client.get(\"/test-cookies\", COOKIES={\"A\": \"na\", \"C\": \"nc\"})\n</code></pre></p>"},{"location":"guides/testing/#users","title":"Users","text":"<p>It is also possible to specify a User for the request: <pre><code>    user = User.objects.create(...)\n    client = TestClient(router)\n    # The request will be made with user logged in\n    response = client.get(\"/test-with-user\", user=user)\n</code></pre></p>"},{"location":"guides/testing/#testing-async-operations","title":"Testing async operations","text":"<p>To test operations in async context use <code>TestAsyncClient</code>:</p> <pre><code>from ninja.testing import TestAsyncClient\n\nclient = TestAsyncClient(router)\nresponse = await client.post(\"/test/\")\n</code></pre>"},{"location":"guides/throttling/","title":"Throttling","text":"<p>Throttles allows to control the rate of requests that clients can make to an API. Django Ninja allows to set custom throttlers globally (across all operations in NinjaAPI instance), on router level and each operation individually.</p> <p>Note</p> <p>The application-level throttling that Django Ninja provides should not be considered a security measure or protection against brute forcing or denial-of-service attacks. Deliberately malicious actors will always be able to spoof IP origins. The built-in throttling implementations are implemented using Django's cache framework, and use non-atomic operations to determine the request rate, which may sometimes result in some fuzziness.</p> <p>Django Ninja\u2019s throttling feature is pretty much based on what Django Rest Framework (DRF) uses, which you can check out here. So, if you\u2019ve already got custom throttling set up for DRF, there\u2019s a good chance it\u2019ll work with Django Ninja right out of the box. The key difference is that you need to pass initialized Throttle objects instead of classes (which should give a better performance).</p> <p>You can specify a rate using the format requests/time-unit, where time-unit represents a number of units followed by an optional unit of time. If the unit is omitted, it defaults to seconds. For example, the following are equivalent and all represent \"100 requests per 5 minutes\":</p> <pre><code>* 100/5m\n* 100/300s\n* 100/300\n</code></pre> <p>The following units are supported:</p> <pre><code>* `s` or `sec`\n* `m` or `min`\n* `h` or `hour`\n* `d` or `day`\n</code></pre>"},{"location":"guides/throttling/#usage","title":"Usage","text":""},{"location":"guides/throttling/#global","title":"Global","text":"<p>The following example will limit unauthenticated users to only 10 requests per second, while authenticated can make 100/s</p> <pre><code>from ninja.throttling import AnonRateThrottle, AuthRateThrottle\n\napi = NinjaAPI(\n    throttle=[\n        AnonRateThrottle('10/s'),\n        AuthRateThrottle('100/s'),\n    ],\n)\n</code></pre> <p>Tip</p> <p><code>throttle</code> argument accepts single object and list of throttle objects</p>"},{"location":"guides/throttling/#router-level","title":"Router level","text":"<p>Pass <code>throttle</code> argument either to <code>add_router</code> function</p> <pre><code>api = NinjaAPI()\n...\n\napi.add_router('/sensitive', 'myapp.api.router', throttle=AnonRateThrottle('100/m'))\n</code></pre> <p>or directly to init of the Router class:</p> <pre><code>router = Router(..., throttle=[AnonRateThrottle('1000/h')])\n</code></pre>"},{"location":"guides/throttling/#operation-level","title":"Operation level","text":"<p>If <code>throttle</code> argument is passed to operation - it will overrule all global and router throttles:</p> <pre><code>from ninja.throttling import UserRateThrottle\n\n@api.get('/some', throttle=[UserRateThrottle('10000/d')])\ndef some(request):\n    ...\n</code></pre>"},{"location":"guides/throttling/#builtin-throttlers","title":"Builtin throttlers","text":""},{"location":"guides/throttling/#anonratethrottle","title":"AnonRateThrottle","text":"<p>Will only throttle unauthenticated users. The IP address of the incoming request is used to generate a unique key to throttle against.</p>"},{"location":"guides/throttling/#userratethrottle","title":"UserRateThrottle","text":"<p>Will throttle users (if you use django build-in user authentication) to a given rate of requests across the API. The user id is used to generate a unique key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.</p>"},{"location":"guides/throttling/#authratethrottle","title":"AuthRateThrottle","text":"<p>Will throttle by Django ninja authentication to a given rate of requests across the API.  Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.</p> <p>Note: the cache key in case of <code>request.auth</code> will be generated by <code>sha256(str(request.auth))</code> - so if you returning some custom objects inside authentication make sure to implement <code>__str__</code> method that will return a unique value for the user.</p>"},{"location":"guides/throttling/#custom-throttles","title":"Custom throttles","text":"<p>To create a custom throttle, override <code>BaseThrottle</code> (or any of builtin throttles) and implement <code>.allow_request(self, request)</code>. The method should return <code>True</code> if the request should be allowed, and <code>False</code> otherwise.</p> <p>Example</p> <pre><code>from ninja.throttling import AnonRateThrottle\n\nclass NoReadsThrottle(AnonRateThrottle):\n    \"\"\"Do not throttle GET requests\"\"\"\n\n    def allow_request(self, request):\n        if request.method == \"GET\":\n            return True\n        return super().allow_request(request)\n</code></pre>"},{"location":"guides/urls/","title":"Reverse Resolution of URLS","text":"<p>A reverse URL name is generated for each method in a Django Ninja Schema (or <code>Router</code>).</p>"},{"location":"guides/urls/#how-urls-are-generated","title":"How URLs are generated","text":"<p>The URLs are all contained within a namespace, which defaults to <code>\"api-1.0.0\"</code>, and each URL name matches the function it is decorated. </p> <p>For example:</p> <pre><code>api = NinjaAPI()\n\n@api.get(\"/\")\ndef index(request):\n    ...\n\nindex_url = reverse_lazy(\"api-1.0.0:index\")\n</code></pre> <p>This implicit URL name will only be set for the first operation for each API path.  If you don't want any implicit reverse URL name generated, just explicitly specify <code>url_name=\"\"</code> (an empty string) on the method decorator.</p>"},{"location":"guides/urls/#changing-the-url-name","title":"Changing the URL name","text":"<p>Rather than using the default URL name, you can specify it explicitly as a property on the method decorator.</p> <pre><code>@api.get(\"/users\", url_name=\"user_list\")\ndef users(request):\n    ...\n\nusers_url = reverse_lazy(\"api-1.0.0:user_list\")\n</code></pre> <p>This will override any implicit URL name to this API path.</p>"},{"location":"guides/urls/#overriding-default-url-names","title":"Overriding default url names","text":"<p>You can also override implicit url naming by overwriting the <code>get_operation_url_name</code> method:</p> <pre><code>class MyAPI(NinjaAPI):\n    def get_operation_url_name(self, operation, router):\n        return operation.view_func.__name__ + '_my_extra_suffix'\n\napi = MyAPI()\n</code></pre>"},{"location":"guides/urls/#customizing-the-namespace","title":"Customizing the namespace","text":"<p>The default URL namespace is built by prepending the Schema's version with <code>\"api-\"</code>, however you can explicitly specify the namespace by overriding the <code>urls_namespace</code> attribute of the <code>NinjaAPI</code> Schema class.</p> <pre><code>api = NinjaAPI(auth=token_auth, version='2')\napi_private = NinjaAPI(auth=session_auth, urls_namespace='private_api')\n\napi_users_url = reverse_lazy(\"api-2:users\")\nprivate_api_admins_url = reverse_lazy(\"private_api:admins\")\n</code></pre>"},{"location":"guides/versioning/","title":"Versioning","text":""},{"location":"guides/versioning/#different-api-version-numbers","title":"Different API version numbers","text":"<p>With Django Ninja it's easy to run multiple API versions from a single Django project.</p> <p>All you have to do is create two or more NinjaAPI instances with different <code>version</code> arguments:</p> <p>api_v1.py:</p> <pre><code>from ninja import NinjaAPI\n\n\napi = NinjaAPI(version='1.0.0')\n\n@api.get('/hello')\ndef hello(request):\n    return {'message': 'Hello from V1'}\n</code></pre> <p>api_v2.py:</p> <pre><code>from ninja import NinjaAPI\n\n\napi = NinjaAPI(version='2.0.0')\n\n@api.get('/hello')\ndef hello(request):\n    return {'message': 'Hello from V2'}\n</code></pre> <p>and then in urls.py:</p> <pre><code>...\nfrom api_v1 import api as api_v1\nfrom api_v2 import api as api_v2\n\n\nurlpatterns = [\n    ...\n    path('api/v1/', api_v1.urls),\n    path('api/v2/', api_v2.urls),\n]\n</code></pre> <p>Now you can go to different OpenAPI docs pages for each version:</p> <ul> <li>http://127.0.0.1/api/v1/docs</li> <li>http://127.0.0.1/api/v2/docs</li> </ul>"},{"location":"guides/versioning/#different-business-logic","title":"Different business logic","text":"<p>In the same way, you can define a different API for different components or areas:</p> <pre><code>...\n\n\napi = NinjaAPI(auth=token_auth, urls_namespace='public_api')\n...\n\napi_private = NinjaAPI(auth=session_auth, urls_namespace='private_api')\n...\n\n\nurlpatterns = [\n    ...\n    path('api/', api.urls),\n    path('internal-api/', api_private.urls),\n]\n</code></pre> <p>Note</p> <p>If you use different NinjaAPI instances, you need to define different <code>version</code>s or different <code>urls_namespace</code>s.</p>"},{"location":"guides/input/body/","title":"Request Body","text":"<p>Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created.</p> <p>To declare a request body, you need to use Django Ninja <code>Schema</code>.</p> <p>Info</p> <p>Under the hood Django Ninja uses Pydantic models with all their power and benefits. The alias <code>Schema</code> was chosen to avoid confusion in code when using Django models, as Pydantic's model class is called Model by default, and conflicts with Django's Model class.</p>"},{"location":"guides/input/body/#import-schema","title":"Import Schema","text":"<p>First, you need to import <code>Schema</code> from <code>ninja</code>:</p> <pre><code>from typing import Optional\nfrom ninja import Schema\n\n\nclass Item(Schema):\n    name: str\n    description: Optional[str] = None\n    price: float\n    quantity: int\n\n\n@api.post(\"/items\")\ndef create(request, item: Item):\n    return item\n</code></pre>"},{"location":"guides/input/body/#create-your-data-model","title":"Create your data model","text":"<p>Then you declare your data model as a class that inherits from <code>Schema</code>.</p> <p>Use standard Python types for all the attributes:</p> <pre><code>from typing import Optional\nfrom ninja import Schema\n\n\nclass Item(Schema):\n    name: str\n    description: Optional[str] = None\n    price: float\n    quantity: int\n\n\n@api.post(\"/items\")\ndef create(request, item: Item):\n    return item\n</code></pre> <p>Note: if you use <code>None</code> as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \"<code>object</code>\" (or Python <code>dict</code>) like:</p> <pre><code>{\n    \"name\": \"Katana\",\n    \"description\": \"An optional description\",\n    \"price\": 299.00,\n    \"quantity\": 10\n}\n</code></pre> <p>...as <code>description</code> is optional (with a default value of <code>None</code>), this JSON \"<code>object</code>\" would also be valid:</p> <pre><code>{\n    \"name\": \"Katana\",\n    \"price\": 299.00,\n    \"quantity\": 10\n}\n</code></pre>"},{"location":"guides/input/body/#declare-it-as-a-parameter","title":"Declare it as a parameter","text":"<p>To add it to your path operation, declare it the same way you declared the path and query parameters:</p> <pre><code>from typing import Optional\nfrom ninja import Schema\n\n\nclass Item(Schema):\n    name: str\n    description: Optional[str] = None\n    price: float\n    quantity: int\n\n\n@api.post(\"/items\")\ndef create(request, item: Item):\n    return item\n</code></pre> <p>... and declare its type as the model you created, <code>Item</code>.</p>"},{"location":"guides/input/body/#results","title":"Results","text":"<p>With just that Python type declaration, Django Ninja will:</p> <ul> <li>Read the body of the request as JSON.</li> <li>Convert the corresponding types (if needed).</li> <li>Validate the data.<ul> <li>If the data is invalid, it will return a nice and meaningful error, indicating exactly where and what the incorrect data was.</li> </ul> </li> <li>Give you the received data in the parameter <code>item</code>.<ul> <li>Because you declared it in the function to be of type <code>Item</code>, you will also have all the editor support   (completion, etc.) for all the attributes and their types.</li> </ul> </li> <li>Generate JSON Schema definitions for   your models, and you can also use them anywhere else you like if it makes sense for your project.</li> <li>Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UI's.</li> </ul>"},{"location":"guides/input/body/#automatic-docs","title":"Automatic docs","text":"<p>The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs:</p> <p></p> <p>... and they will be also used in the API docs inside each path operation that needs them:</p> <p></p>"},{"location":"guides/input/body/#editor-support","title":"Editor support","text":"<p>In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a <code>dict</code> instead of a Schema object):</p> <p></p> <p>The previous screenshots were taken with Visual Studio Code.</p> <p>You would get the same editor support with PyCharm and most of the other Python editors.</p>"},{"location":"guides/input/body/#request-body-path-parameters","title":"Request body + path parameters","text":"<p>You can declare path parameters and body requests at the same time.</p> <p>Django Ninja will recognize that the function parameters that match path parameters should be taken from the path, and that function parameters that are declared with <code>Schema</code> should be taken from the request body.</p> <pre><code>from ninja import Schema\n\n\nclass Item(Schema):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n\n@api.put(\"/items/{item_id}\")\ndef update(request, item_id: int, item: Item):\n    return {\"item_id\": item_id, \"item\": item.dict()}\n</code></pre>"},{"location":"guides/input/body/#request-body-path-query-parameters","title":"Request body + path + query parameters","text":"<p>You can also declare body, path and query parameters, all at the same time.</p> <p>Django Ninja will recognize each of them and take the data from the correct place.</p> <pre><code>from ninja import Schema\n\n\nclass Item(Schema):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n\n@api.post(\"/items/{item_id}\")\ndef update(request, item_id: int, item: Item, q: str):\n    return {\"item_id\": item_id, \"item\": item.dict(), \"q\": q}\n</code></pre> <p>The function parameters will be recognized as follows:</p> <ul> <li>If the parameter is also declared in the path, it will be used as a path parameter.</li> <li>If the parameter is of a singular type (like <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, etc.), it will be interpreted as a query parameter.</li> <li>If the parameter is declared to be of the type of Schema (or Pydantic <code>BaseModel</code>), it will be interpreted as a request body.</li> </ul>"},{"location":"guides/input/file-params/","title":"File uploads","text":"<p>Handling files are no different from other parameters.</p> <pre><code>from ninja import NinjaAPI, File\nfrom ninja.files import UploadedFile\n\n@api.post(\"/upload\")\ndef upload(request, file: File[UploadedFile]):\n    data = file.read()\n    return {'name': file.name, 'len': len(data)}\n</code></pre> <p><code>UploadedFile</code> is an alias to Django's UploadFile and has all the methods and attributes to access the uploaded file:</p> <ul> <li>read()</li> <li>multiple_chunks(chunk_size=None)</li> <li>chunks(chunk_size=None)</li> <li>name</li> <li>size</li> <li>content_type</li> <li>content_type_extra</li> <li>charset</li> <li>etc.</li> </ul>"},{"location":"guides/input/file-params/#uploading-array-of-files","title":"Uploading array of files","text":"<p>To upload several files at the same time, just declare a <code>List</code> of <code>UploadedFile</code>:</p> <pre><code>from typing import List\nfrom ninja import NinjaAPI, File\nfrom ninja.files import UploadedFile\n\n@api.post(\"/upload-many\")\ndef upload_many(request, files: File[List[UploadedFile]]):\n    return [f.name for f in files]\n</code></pre>"},{"location":"guides/input/file-params/#uploading-files-with-extra-fields","title":"Uploading files with extra fields","text":"<p>Note: The HTTP protocol does not allow you to send files in <code>application/json</code> format by default (unless you encode it somehow to JSON on client side)</p> <p>To send files along with some extra attributes, you need to send bodies with <code>multipart/form-data</code> encoding. You can do it by simply marking fields with <code>Form</code>:</p> <pre><code>from ninja import NinjaAPI, Schema, UploadedFile, Form, File\nfrom datetime import date\n\napi = NinjaAPI()\n\n\nclass UserDetails(Schema):\n    first_name: str\n    last_name: str\n    birthdate: date\n\n\n@api.post('/users')\ndef create_user(request, details: Form[UserDetails], file: File[UploadedFile]):\n    return [details.dict(), file.name]\n</code></pre> <p>Note: in this case all fields should be send as form fields</p> <p>You can as well send payload in single field as JSON - just remove the Form mark from:</p> <pre><code>@api.post('/users')\ndef create_user(request, details: UserDetails, file: File[UploadedFile]):\n    return [details.dict(), file.name]\n</code></pre> <p>this will expect from the client side to send data as `multipart/form-data with 2 fields:</p> <ul> <li>details: JSON as string</li> <li>file: file</li> </ul>"},{"location":"guides/input/file-params/#list-of-files-with-extra-info","title":"List of files with extra info","text":"<pre><code>@api.post('/users')\ndef create_user(request, details: Form[UserDetails], files: File[list[UploadedFile]]):\n    return [details.dict(), [f.name for f in files]]\n</code></pre>"},{"location":"guides/input/file-params/#optional-file-input","title":"Optional file input","text":"<p>If you would like the file input to be optional, all that you have to do is to pass <code>None</code> to the <code>File</code> type, like so:</p> <pre><code>@api.post('/users')\ndef create_user(request, details: Form[UserDetails], avatar: File[UploadedFile] = None):\n    user = add_user_to_database(details)\n    if avatar is not None:\n        set_user_avatar(user)\n</code></pre>"},{"location":"guides/input/file-params/#handling-requestfiles-in-putpatch-requests","title":"Handling request.FILES in PUT/PATCH Requests","text":"<p>Problem</p> <pre><code>@api.put(\"/upload\") # !!!!\ndef upload(request, file: File[UploadedFile]):\n   ...\n</code></pre> <p>For some historical reasosns Django\u2019s <code>request.FILES</code> is populated only for POST requests by default. When using HTTP PUT or PATCH methods with file uploads (e.g., multipart/form-data), request.FILES will not contain uploaded files. This is a known Django behavior, not specific to Django Ninja.</p> <p>As a result, views expecting files in PUT or PATCH requests may not behave correctly, since request.FILES will be empty.</p> <p>Solution</p> <p>Django Ninja provides a built-in middleware to automatically fix this behavior: <code>ninja.compatibility.files.fix_request_files_middleware</code></p> <p>This middleware will manually parse multipart/form-data for PUT and PATCH requests and populate request.FILES, making file uploads work as expected across all HTTP methods.</p> <p>Usage</p> <p>To enable the middleware, add the following to your Django settings:</p> <pre><code>MIDDLEWARE = [\n    # ... your existing middleware ...\n    \"ninja.compatibility.files.fix_request_files_middleware\",\n]\n</code></pre> <p>Auto-detection</p> <p>When Django Ninja detects a PUT or PATCH  etc methods with multipart/form-data and expected FILES  - it will throw an error message suggesting you install the compatibility middleware:</p> <p>Note: This middleware does not interfere with normal POST behavior or any other methods.</p>"},{"location":"guides/input/filtering/","title":"Filtering","text":"<p>If you want to allow the user to filter your querysets by a number of different attributes, it makes sense to encapsulate your filters into a <code>FilterSchema</code> class. <code>FilterSchema</code> is a regular <code>Schema</code>, so it's using all the necessary features of Pydantic, but it also adds some bells and whistles that ease the translation of the user-facing filtering parameters into database queries. </p> <p>Start off with defining a subclass of <code>FilterSchema</code>:</p> <pre><code>from ninja import FilterSchema, Field\nfrom typing import Optional\n\n\nclass BookFilterSchema(FilterSchema):\n    name: Optional[str] = None\n    author: Optional[str] = None\n    created_after: Optional[datetime] = None\n</code></pre> <p>Next, use this schema in conjunction with <code>Query</code> in your API handler: <pre><code>@api.get(\"/books\")\ndef list_books(request, filters: BookFilterSchema = Query(...)):\n    books = Book.objects.all()\n    books = filters.filter(books)\n    return books\n</code></pre></p> <p>Just like described in defining query params using schema, Django Ninja converts the fields defined in <code>BookFilterSchema</code> into query parameters.</p> <p>You can use a shorthand one-liner <code>.filter()</code> to apply those filters to your queryset: <pre><code>@api.get(\"/books\")\ndef list_books(request, filters: BookFilterSchema = Query(...)):\n    books = Book.objects.all()\n    books = filters.filter(books)\n    return books\n</code></pre></p> <p>Under the hood, <code>FilterSchema</code> converts its fields into Q expressions which it then combines and uses to filter your queryset.</p> <p>Alternatively to using the <code>.filter</code> method, you can get the prepared <code>Q</code>-expression and perform the filtering yourself. That can be useful, when you have some additional queryset filtering on top of what you expose to the user through the API: <pre><code>@api.get(\"/books\")\ndef list_books(request, filters: BookFilterSchema = Query(...)):\n\n    # Never serve books from inactive publishers and authors\n    q = Q(author__is_active=True) | Q(publisher__is_active=True)\n\n    # But allow filtering the rest of the books\n    q &amp;= filters.get_filter_expression()\n    return Book.objects.filter(q)\n</code></pre></p> <p>By default, the filters will behave the following way:</p> <ul> <li><code>None</code> values will be ignored and not filtered against;</li> <li>Every non-<code>None</code> field will be converted into a <code>Q</code>-expression based on the <code>Field</code> definition of each field;</li> <li>All <code>Q</code>-expressions will be merged into one using <code>AND</code> logical operator;</li> <li>The resulting <code>Q</code>-expression is used to filter the queryset and return you a queryset with a <code>.filter</code> clause applied.</li> </ul>"},{"location":"guides/input/filtering/#customizing-fields","title":"Customizing Fields","text":"<p>By default, <code>FilterSet</code> will use the field names to generate Q expressions: <pre><code>class BookFilterSchema(FilterSchema):\n    name: Optional[str] = None\n</code></pre> The <code>name</code> field will be converted into <code>Q(name=...)</code> expression.</p> <p>When your database lookups are more complicated than that, you can explicitly specify them in the field definition using a <code>\"q\"</code> kwarg: <pre><code>class BookFilterSchema(FilterSchema):\n    name: Optional[str] = Field(None, q='name__icontains')\n</code></pre> You can even specify multiple lookup keyword argument names as a list: <pre><code>class BookFilterSchema(FilterSchema):\n    search: Optional[str] = Field(None, q=['name__icontains',\n                                     'author__name__icontains',\n                                     'publisher__name__icontains'])\n</code></pre> And to make generic fields, you can make the field name implicit by skipping it: <pre><code>IContainsField = Annotated[Optional[str], Field(None, q='__icontains')]\n\nclass BookFilterSchema(FilterSchema):\n    name: IContainsField\n</code></pre> By default, field-level expressions are combined using <code>\"OR\"</code> connector, so with the above setup, a query parameter <code>?search=foobar</code> will search for books that have \"foobar\" in either of their name, author or publisher.</p>"},{"location":"guides/input/filtering/#combining-expressions","title":"Combining expressions","text":"<p>By default,</p> <ul> <li>Field-level expressions are joined together using <code>OR</code> operator.</li> <li>The fields themselves are joined together using <code>AND</code> operator.</li> </ul> <p>So, with the following <code>FilterSchema</code>... <pre><code>class BookFilterSchema(FilterSchema):\n    search: Optional[str] = Field(None, q=['name__icontains', 'author__name__icontains'])\n    popular: Optional[bool] = None\n</code></pre> ...and the following query parameters from the user <pre><code>http://localhost:8000/api/books?search=harry&amp;popular=true\n</code></pre> the <code>FilterSchema</code> instance will look for popular books that have <code>harry</code> in the book's or author's name. </p> <p>You can customize this behavior using an <code>expression_connector</code> argument in field-level and class-level definition: <pre><code>class BookFilterSchema(FilterSchema):\n    active: Optional[bool] = Field(None, q=['is_active', 'publisher__is_active'],\n                                   expression_connector='AND')\n    name: Optional[str] = Field(None, q='name__icontains')\n\n    class Config:\n        expression_connector = 'OR'\n</code></pre></p> <p>An expression connector can take the values of <code>\"OR\"</code>, <code>\"AND\"</code> and <code>\"XOR\"</code>, but the latter is only supported in Django starting with 4.1.</p> <p>Now, a request with these query parameters  <pre><code>http://localhost:8000/api/books?name=harry&amp;active=true\n</code></pre> ...shall search for books that have <code>harry</code> in their name or are active themselves and are published by active publishers.</p>"},{"location":"guides/input/filtering/#filtering-by-nones","title":"Filtering by Nones","text":"<p>You can make the <code>FilterSchema</code> treat <code>None</code> as a valid value that should be filtered against.</p> <p>This can be done on a field level with a <code>ignore_none</code> kwarg: <pre><code>class BookFilterSchema(FilterSchema):\n    name: Optional[str] = Field(None, q='name__icontains')\n    tag: Optional[str] = Field(None, q='tag', ignore_none=False)\n</code></pre></p> <p>This way when no other value for <code>\"tag\"</code> is provided by the user, the filtering will always include a condition <code>tag=None</code>.</p> <p>You can also specify this settings for all fields at the same time in the Config: <pre><code>class BookFilterSchema(FilterSchema):\n    name: Optional[str] = Field(None, q='name__icontains')\n    tag: Optional[str] = Field(None, q='tag', ignore_none=False)\n\n    class Config:\n        ignore_none = False\n</code></pre></p>"},{"location":"guides/input/filtering/#custom-expressions","title":"Custom expressions","text":"<p>Sometimes you might want to have complex filtering scenarios that cannot be handled by individual Field annotations. For such cases you can implement your field filtering logic as a custom method. Simply define a method called <code>filter_&lt;fieldname&gt;</code> which takes a filter value and returns a Q expression:</p> <p><pre><code>class BookFilterSchema(FilterSchema):\n    tag: Optional[str] = None\n    popular: Optional[bool] = None\n\n    def filter_popular(self, value: bool) -&gt; Q:\n        return Q(view_count__gt=1000) | Q(download_count__gt=100) if value else Q()\n</code></pre> Such field methods take precedence over what is specified in the <code>Field()</code> definition of the corresponding fields.</p> <p>If that is not enough, you can implement your own custom filtering logic for the entire <code>FilterSet</code> class in a <code>custom_expression</code> method:</p> <p><pre><code>class BookFilterSchema(FilterSchema):\n    name: Optional[str] = None\n    popular: Optional[bool] = None\n\n    def custom_expression(self) -&gt; Q:\n        q = Q()\n        if self.name:\n            q &amp;= Q(name__icontains=self.name)\n        if self.popular:\n            q &amp;= (\n                Q(view_count__gt=1000) |\n                Q(downloads__gt=100) |\n                Q(tag='popular')\n            )\n        return q\n</code></pre> The <code>custom_expression</code> method takes precedence over any other definitions described earlier, including <code>filter_&lt;fieldname&gt;</code> methods.</p>"},{"location":"guides/input/form-params/","title":"Form data","text":"<p>Django Ninja also allows you to parse and validate <code>request.POST</code> data (aka <code>application/x-www-form-urlencoded</code> or <code>multipart/form-data</code>).</p>"},{"location":"guides/input/form-params/#form-data-as-params","title":"Form Data as params","text":"<pre><code>from ninja import NinjaAPI, Form\n\n@api.post(\"/login\")\ndef login(request, username: Form[str], password: Form[str]):\n    return {'username': username, 'password': '*****'}\n</code></pre> <p>Note the following:</p> <p>1) You need to import the <code>Form</code> class from <code>ninja</code> <pre><code>from ninja import Form\n</code></pre></p> <p>2) Use <code>Form</code> as default value for your parameter: <pre><code>username: Form[str]\n</code></pre></p>"},{"location":"guides/input/form-params/#using-a-schema","title":"Using a Schema","text":"<p>In a similar manner to Body, you can use a Schema to organize your parameters.</p> <pre><code>from ninja import Form, Schema\n\n\nclass Item(Schema):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n\n@api.post(\"/items\")\ndef create(request, item: Form[Item]):\n    return item\n</code></pre>"},{"location":"guides/input/form-params/#request-form-path-query-parameters","title":"Request form + path + query parameters","text":"<p>In a similar manner to Body, you can use Form data in combination with other parameter sources.</p> <p>You can declare query and path and form field, and etc... parameters at the same time.</p> <p>Django Ninja will recognize that the function parameters that match path parameters should be taken from the path, and that function parameters that are declared with <code>Form(...)</code> should be taken from the request form fields, etc.</p> <pre><code>from ninja import Form, Schema\n\n\nclass Item(Schema):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n\n@api.post(\"/items/{item_id}\")\ndef update(request, item_id: int, q: str, item: Form[Item]):\n    return {\"item_id\": item_id, \"item\": item.dict(), \"q\": q}\n</code></pre>"},{"location":"guides/input/form-params/#mapping-empty-form-field-to-default","title":"Mapping Empty Form Field to Default","text":"<p>Form fields that are optional, are often sent with an empty value. This value is interpreted as an empty string, and thus may fail validation for fields such as <code>int</code> or <code>bool</code>.</p> <p>This can be fixed, as described in the Pydantic docs, by using Generic Classes as Types.</p> <pre><code>from ninja import Form, Schema\nfrom typing import Annotated, TypeVar\nfrom pydantic import WrapValidator\nfrom pydantic_core import PydanticUseDefault\n\n\ndef _empty_str_to_default(v, handler, info):\n    if isinstance(v, str) and v == '':\n        raise PydanticUseDefault\n    return handler(v)\n\n\nT = TypeVar('T')\nEmptyStrToDefault = Annotated[T, WrapValidator(_empty_str_to_default)]\n\n\nclass Item(Schema):\n    name: str\n    description: str = None\n    price: EmptyStrToDefault[float] = 0.0\n    quantity: EmptyStrToDefault[int] = 0\n    in_stock: EmptyStrToDefault[bool] = True\n\n\n@api.post(\"/items-blank-default\")\ndef update(request, item: Form[Item]):\n    return item.dict()\n</code></pre>"},{"location":"guides/input/operations/","title":"HTTP Methods","text":""},{"location":"guides/input/operations/#defining-operations","title":"Defining operations","text":"<p>An <code>operation</code> can be one of the following HTTP methods:</p> <ul> <li>GET</li> <li>POST</li> <li>PUT</li> <li>DELETE</li> <li>PATCH</li> </ul> <p>Django Ninja comes with a decorator for each operation:</p> <pre><code>@api.get(\"/path\")\ndef get_operation(request):\n    ...\n\n@api.post(\"/path\")\ndef post_operation(request):\n    ...\n\n@api.put(\"/path\")\ndef put_operation(request):\n    ...\n\n@api.delete(\"/path\")\ndef delete_operation(request):\n    ...\n\n@api.patch(\"/path\")\ndef patch_operation(request):\n    ...\n</code></pre> <p>See the operations parameters reference docs for information on what you can pass to any of these decorators.</p>"},{"location":"guides/input/operations/#handling-multiple-methods","title":"Handling multiple methods","text":"<p>If you need to handle multiple methods with a single function for a given path, you can use the <code>api_operation</code> decorator:</p> <pre><code>@api.api_operation([\"POST\", \"PATCH\"], \"/path\")\ndef mixed_operation(request):\n    ...\n</code></pre> <p>This feature can also be used to implement other HTTP methods that don't have corresponding Django Ninja methods, such as <code>HEAD</code> or <code>OPTIONS</code>.</p> <pre><code>@api.api_operation([\"HEAD\", \"OPTIONS\"], \"/path\")\ndef mixed_operation(request):\n    ...\n</code></pre>"},{"location":"guides/input/path-params/","title":"Path parameters","text":"<p>You can declare path \"parameters\" with the same syntax used by Python format-strings (which luckily also matches the OpenAPI path parameters):</p> <pre><code>@api.get(\"/items/{item_id}\")\ndef read_item(request, item_id):\n    return {\"item_id\": item_id}\n</code></pre> <p>The value of the path parameter <code>item_id</code> will be passed to your function as the argument <code>item_id</code>.</p> <p>So, if you run this example and go to http://localhost:8000/api/items/foo, you will see this response:</p> <pre><code>{\"item_id\":\"foo\"}\n</code></pre>"},{"location":"guides/input/path-params/#path-parameters-with-types","title":"Path parameters with types","text":"<p>You can declare the type of path parameter in the function using standard Python type annotations:</p> <pre><code>@api.get(\"/items/{item_id}\")\ndef read_item(request, item_id: int):\n    return {\"item_id\": item_id}\n</code></pre> <p>In this case,<code>item_id</code> is declared to be an <code>int</code>. This will give you editor and linter support for error checks, completion, etc.</p> <p>If you run this in your browser with http://localhost:8000/api/items/3, you will see this response: <pre><code>{\"item_id\":3}\n</code></pre></p> <p>Tip</p> <p>Notice that the value your function received (and returned) is 3, as a Python <code>int</code> - not a string <code>\"3\"</code>. So, with just that type declaration, Django Ninja gives you automatic request \"parsing\" and validation.</p>"},{"location":"guides/input/path-params/#data-validation","title":"Data validation","text":"<p>On the other hand, if you go to the browser at http://localhost:8000/api/items/foo (<code>\"foo\"</code> is not int), you will see an HTTP error like this:</p> <pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                \"path\",\n                \"item_id\"\n            ],\n            \"msg\": \"value is not a valid integer\",\n            \"type\": \"type_error.integer\"\n        }\n    ]\n}\n</code></pre>"},{"location":"guides/input/path-params/#django-path-converters","title":"Django Path Converters","text":"<p>You can use Django Path Converters to help parse the path:</p> <pre><code>@api.get(\"/items/{int:item_id}\")\ndef read_item(request, item_id):\n    return {\"item_id\": item_id}\n</code></pre> <p>In this case,<code>item_id</code> will be parsed as an <code>int</code>. If <code>item_id</code> is not a valid <code>int</code>, the url will not match.  (e.g. if no other path matches, a 404 Not Found will be returned)</p> <p>Tip</p> <p>Notice that, since Django Ninja uses a default type of <code>str</code> for unannotated parameters, the value the function above received (and returned) is <code>\"3\"</code>, as a Python <code>str</code> - not an integer 3. To receive an <code>int</code>, simply declare <code>item_id</code> as an <code>int</code> type annotation in the function definition as normal:</p> <pre><code>@api.get(\"/items/{int:item_id}\")\ndef read_item(request, item_id:int):\n    return {\"item_id\": item_id}\n</code></pre>"},{"location":"guides/input/path-params/#path-params-with-slashes","title":"Path params with slashes","text":"<p>Django's <code>path</code> converter allows you to handle path-like parameters:</p> <p><pre><code>@api.get('/dir/{path:value}')\ndef someview(request, value: str):\n    return value\n</code></pre> you can query this operation with <code>/dir/some/path/with-slashes</code> and your <code>value</code> will be equal to <code>some/path/with-slashes</code></p>"},{"location":"guides/input/path-params/#multiple-parameters","title":"Multiple parameters","text":"<p>You can pass as many variables as you want into <code>path</code>, just remember to have unique names and don't forget to use the same names in the function arguments.</p> <pre><code>@api.get(\"/events/{year}/{month}/{day}\")\ndef events(request, year: int, month: int, day: int):\n    return {\"date\": [year, month, day]}\n</code></pre>"},{"location":"guides/input/path-params/#using-schema","title":"Using Schema","text":"<p>You can also use Schema to encapsulate path parameters that depend on each other (and validate them as a group):</p> <pre><code>import datetime\nfrom ninja import Schema, Path\n\n\nclass PathDate(Schema):\n    year: int\n    month: int\n    day: int\n\n    def value(self):\n        return datetime.date(self.year, self.month, self.day)\n\n\n@api.get(\"/events/{year}/{month}/{day}\")\ndef events(request, date: Path[PathDate]):\n    return {\"date\": date.value()}\n</code></pre> <p>Note</p> <p>Notice that here we used a <code>Path</code> source hint to let Django Ninja know that this schema will be applied to path parameters.</p>"},{"location":"guides/input/path-params/#documentation","title":"Documentation","text":"<p>Now, when you open your browser at http://localhost:8000/api/docs, you will see the automatic, interactive, API documentation. </p>"},{"location":"guides/input/query-params/","title":"Query parameters","text":"<p>When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as \"query\" parameters.</p> <pre><code>weapons = [\"Ninjato\", \"Shuriken\", \"Katana\", \"Kama\", \"Kunai\", \"Naginata\", \"Yari\"]\n\n\n@api.get(\"/weapons\")\ndef list_weapons(request, limit: int = 10, offset: int = 0):\n    return weapons[offset: offset + limit]\n</code></pre> <p>To query this operation, you use a URL like:</p> <p><pre><code>http://localhost:8000/api/weapons?offset=0&amp;limit=10\n</code></pre> By default, all GET parameters are strings, and when you annotate your function arguments with types, they are converted to that type and validated against it.</p> <p>The same benefits that apply to path parameters also apply to query parameters:</p> <ul> <li>Editor support (obviously)</li> <li>Data \"parsing\"</li> <li>Data validation</li> <li>Automatic documentation</li> </ul> <p>Note</p> <p>if you do not annotate your arguments, they will be treated as <code>str</code> types</p> <pre><code>@api.get(\"/weapons\")\ndef list_weapons(request, limit, offset):\n    # type(limit) == str\n    # type(offset) == str\n</code></pre>"},{"location":"guides/input/query-params/#defaults","title":"Defaults","text":"<p>As query parameters are not a fixed part of a path, they are optional and can have default values:</p> <pre><code>@api.get(\"/weapons\")\ndef list_weapons(request, limit: int = 10, offset: int = 0):\n    return weapons[offset : offset + limit]\n</code></pre> <p>In the example above we set default values of <code>offset=0</code> and <code>limit=10</code>.</p> <p>So, going to the URL: <pre><code>http://localhost:8000/api/weapons\n</code></pre> would be the same as going to: <pre><code>http://localhost:8000/api/weapons?offset=0&amp;limit=10\n</code></pre> If you go to, for example: <pre><code>http://localhost:8000/api/weapons?offset=20\n</code></pre></p> <p>the parameter values in your function will be:</p> <ul> <li><code>offset=20</code>  (because you set it in the URL)</li> <li><code>limit=10</code>  (because that was the default value)</li> </ul>"},{"location":"guides/input/query-params/#required-and-optional-parameters","title":"Required and optional parameters","text":"<p>You can declare required or optional GET parameters in the same way as declaring Python function arguments:</p> <pre><code>weapons = [\"Ninjato\", \"Shuriken\", \"Katana\", \"Kama\", \"Kunai\", \"Naginata\", \"Yari\"]\n\n\n@api.get(\"/weapons/search\")\ndef search_weapons(request, q: str, offset: int = 0):\n    results = [w for w in weapons if q in w.lower()]\n    return results[offset : offset + 10]\n</code></pre> <p>In this case, Django Ninja will always validate that you pass the <code>q</code> param in the GET, and the <code>offset</code> param is an optional integer.</p>"},{"location":"guides/input/query-params/#get-parameters-type-conversion","title":"GET parameters type conversion","text":"<p>Let's declare multiple type arguments: <pre><code>from datetime import date\n\n\n@api.get(\"/example\")\ndef example(request, s: str = None, b: bool = None, d: date = None, i: int = None):\n    return [s, b, d, i]\n</code></pre> The <code>str</code> type is passed as is.</p> <p>For the <code>bool</code> type, all the following: <pre><code>http://localhost:8000/api/example?b=1\nhttp://localhost:8000/api/example?b=True\nhttp://localhost:8000/api/example?b=true\nhttp://localhost:8000/api/example?b=on\nhttp://localhost:8000/api/example?b=yes\n</code></pre> or any other case variation (uppercase, first letter in uppercase, etc.), your function will see the parameter <code>b</code> with a <code>bool</code> value of <code>True</code>, otherwise as <code>False</code>.</p> <p>Date can be both date string and integer (unix timestamp):</p> <pre>\nhttp://localhost:8000/api/example?d=1577836800  # same as 2020-01-01\nhttp://localhost:8000/api/example?d=2020-01-01\n</pre>"},{"location":"guides/input/query-params/#using-schema","title":"Using Schema","text":"<p>You can also use Schema to encapsulate GET parameters:</p> <pre><code>import datetime\nfrom typing import List\n\nfrom pydantic import Field\n\nfrom ninja import Query, Schema\n\n\nclass Filters(Schema):\n    limit: int = 100\n    offset: int = None\n    query: str = None\n    category__in: List[str] = Field(None, alias=\"categories\")\n\n\n@api.get(\"/filter\")\ndef events(request, filters: Query[Filters]):\n    return {\"filters\": filters.dict()}\n</code></pre> <p>For more complex filtering scenarios please refer to filtering.</p>"},{"location":"guides/input/request-parsers/","title":"Request parsers","text":"<p>In most cases, the default content type for REST API's is JSON, but in case you need to work with other content types (like YAML, XML, CSV) or use faster JSON parsers, Django Ninja provides a <code>parser</code> configuration.</p> <pre><code>api = NinjaAPI(parser=MyYamlParser())\n</code></pre> <p>To create your own parser, you need to extend the <code>ninja.parser.Parser</code> class, and override the <code>parse_body</code> method.</p>"},{"location":"guides/input/request-parsers/#example-yaml-parser","title":"Example YAML Parser","text":"<p>Let's create our custom YAML parser:</p> <pre><code>import yaml\nfrom typing import List\nfrom ninja import NinjaAPI\nfrom ninja.parser import Parser\n\n\nclass MyYamlParser(Parser):\n    def parse_body(self, request):\n        return yaml.safe_load(request.body)\n\n\napi = NinjaAPI(parser=MyYamlParser())\n\n\nclass Payload(Schema):\n    ints: List[int]\n    string: str\n    f: float\n\n\n@api.post('/yaml')\ndef operation(request, payload: Payload):\n    return payload.dict()\n</code></pre> <p>If you now send YAML like this as the request body:</p> <pre><code>ints:\n - 0\n - 1\nstring: hello\nf: 3.14\n</code></pre> <p>it will be correctly parsed, and you should have JSON output like this:</p> <pre><code>{\n  \"ints\": [\n    0,\n    1\n  ],\n  \"string\": \"hello\",\n  \"f\": 3.14\n}\n</code></pre>"},{"location":"guides/input/request-parsers/#example-orjson-parser","title":"Example ORJSON Parser","text":"<p>orjson is a fast, accurate JSON library for Python. It benchmarks as the fastest Python library for JSON and is more accurate than the standard <code>json</code> library or other third-party libraries.</p> <pre><code>pip install orjson\n</code></pre> <p>Parser code:</p> <pre><code>import orjson\nfrom ninja import NinjaAPI\nfrom ninja.parser import Parser\n\n\nclass ORJSONParser(Parser):\n    def parse_body(self, request):\n        return orjson.loads(request.body)\n\n\napi = NinjaAPI(parser=ORJSONParser())\n</code></pre>"},{"location":"guides/response/","title":"Response Schema","text":"<p>Django Ninja allows you to define the schema of your responses both for validation and documentation purposes.</p> <p>Imagine you need to create an API operation that creates a user. The input parameter would be username+password, but output of this operation should be id+username (without the password).</p> <p>Let's create the input schema:</p> <pre><code>from ninja import Schema\n\nclass UserIn(Schema):\n    username: str\n    password: str\n\n\n@api.post(\"/users/\")\ndef create_user(request, data: UserIn):\n    user = User(username=data.username) # User is django auth.User\n    user.set_password(data.password)\n    user.save()\n    # ... return ?\n</code></pre> <p>Now let's define the output schema, and pass it as a <code>response</code> argument to the <code>@api.post</code> decorator:</p> <pre><code>from ninja import Schema\n\nclass UserIn(Schema):\n    username: str\n    password: str\n\n\nclass UserOut(Schema):\n    id: int\n    username: str\n\n\n@api.post(\"/users/\", response=UserOut)\ndef create_user(request, data: UserIn):\n    user = User(username=data.username)\n    user.set_password(data.password)\n    user.save()\n    return user\n</code></pre> <p>Django Ninja will use this <code>response</code> schema to:</p> <ul> <li>convert the output data to declared schema</li> <li>validate the data</li> <li>add an OpenAPI schema definition</li> <li>it will be used by the automatic documentation systems</li> <li>and, most importantly, it will limit the output data only to the fields only defined in the schema.</li> </ul>"},{"location":"guides/response/#nested-objects","title":"Nested objects","text":"<p>There is also often a need to return responses with some nested/child objects.</p> <p>Imagine we have a <code>Task</code> Django model with a <code>User</code> ForeignKey:</p> <pre><code>from django.db import models\n\nclass Task(models.Model):\n    title = models.CharField(max_length=200)\n    is_completed = models.BooleanField(default=False)\n    owner = models.ForeignKey(\"auth.User\", null=True, blank=True)\n</code></pre> <p>Now let's output all tasks, and for each task, output some fields about the user.</p> <pre><code>from typing import List\nfrom ninja import Schema\n\nclass UserSchema(Schema):\n    id: int\n    first_name: str\n    last_name: str\n\nclass TaskSchema(Schema):\n    id: int\n    title: str\n    is_completed: bool\n    owner: UserSchema = None  # ! None - to mark it as optional\n\n\n@api.get(\"/tasks\", response=List[TaskSchema])\ndef tasks(request):\n    queryset = Task.objects.select_related(\"owner\")\n    return list(queryset)\n</code></pre> <p>If you execute this operation, you should get a response like this:</p> <pre><code>[\n    {\n        \"id\": 1,\n        \"title\": \"Task 1\",\n        \"is_completed\": false,\n        \"owner\": {\n            \"id\": 1,\n            \"first_name\": \"John\",\n            \"last_name\": \"Doe\",\n        }\n    },\n    {\n        \"id\": 2,\n        \"title\": \"Task 2\",\n        \"is_completed\": false,\n        \"owner\": null\n    },\n]\n</code></pre>"},{"location":"guides/response/#aliases","title":"Aliases","text":"<p>Instead of a nested response, you may want to just flatten the response output. The Ninja <code>Schema</code> object extends Pydantic's <code>Field(..., alias=\"\")</code> format to work with dotted responses.</p> <p>Using the models from above, let's make a schema that just includes the task owner's first name inline, and also uses <code>completed</code> rather than <code>is_completed</code>:</p> <pre><code>from ninja import Field, Schema\n\n\nclass TaskSchema(Schema):\n    id: int\n    title: str\n    # The first Field param is the default, use ... for required fields.\n    completed: bool = Field(..., alias=\"is_completed\")\n    owner_first_name: str = Field(None, alias=\"owner.first_name\")\n</code></pre> <p>Aliases also support django template syntax variables access:</p> <pre><code>class TaskSchema(Schema):\n    last_message: str = Field(None, alias=\"message_set.0.text\")\n</code></pre> <pre><code>class TaskSchema(Schema):\n    type: str = Field(None)\n    type_display: str = Field(None, alias=\"get_type_display\") # callable will be executed\n</code></pre>"},{"location":"guides/response/#resolvers","title":"Resolvers","text":"<p>You can also create calculated fields via resolve methods based on the field name.</p> <p>The method must accept a single argument, which will be the object the schema is resolving against.</p> <p>When creating a resolver as a standard method, <code>self</code> gives you access to other validated and formatted attributes in the schema.</p> <pre><code>class TaskSchema(Schema):\n    id: int\n    title: str\n    is_completed: bool\n    owner: Optional[str] = None\n    lower_title: str\n\n    @staticmethod\n    def resolve_owner(obj):\n        if not obj.owner:\n            return\n        return f\"{obj.owner.first_name} {obj.owner.last_name}\"\n\n    def resolve_lower_title(self, obj):\n        return self.title.lower()\n</code></pre>"},{"location":"guides/response/#accessing-extra-context","title":"Accessing extra context","text":"<p>Pydantic v2 allows you to process an extra context that is passed to the serializer. In the following example you can have resolver that gets request object from passed <code>context</code> argument:</p> <pre><code>class Data(Schema):\n    a: int\n    path: str = \"\"\n\n    @staticmethod\n    def resolve_path(obj, context):\n        request = context[\"request\"]\n        return request.path\n</code></pre> <p>if you use this schema for incoming requests - the <code>request</code> object will be automatically passed to context.</p> <p>You can as well pass your own context:</p> <pre><code>data = Data.model_validate({'some': 1}, context={'request': MyRequest()})\n</code></pre>"},{"location":"guides/response/#returning-querysets","title":"Returning querysets","text":"<p>In the previous example we specifically converted a queryset into a list (and executed the SQL query during evaluation).</p> <p>You can avoid that and return a queryset as a result, and it will be automatically evaluated to List:</p> <pre><code>@api.get(\"/tasks\", response=List[TaskSchema])\ndef tasks(request):\n    return Task.objects.all()\n</code></pre> <p>Warning</p> <p>If your operation is async, this example will not work because the ORM query needs to be called safely.</p> <pre><code>@api.get(\"/tasks\", response=List[TaskSchema])\nasync def tasks(request):\n    return Task.objects.all()\n</code></pre> <p>See the async support guide for more information.</p>"},{"location":"guides/response/#filefield-and-imagefield","title":"FileField and ImageField","text":"<p>Django Ninja by default converts files and images (declared with <code>FileField</code> or <code>ImageField</code>) to <code>string</code> URL's.</p> <p>An example:</p> <pre><code>class Picture(models.Model):\n    title = models.CharField(max_length=100)\n    image = models.ImageField(upload_to='images')\n</code></pre> <p>If you need to output to response image field, declare a schema for it as follows:</p> <pre><code>class PictureSchema(Schema):\n    title: str\n    image: str\n</code></pre> <p>Once you output this to a response, the URL will be automatically generated for each object:</p> <pre><code>{\n    \"title\": \"Zebra\",\n    \"image\": \"/static/images/zebra.jpg\"\n}\n</code></pre>"},{"location":"guides/response/#multiple-response-schemas","title":"Multiple Response Schemas","text":"<p>Sometimes you need to define more than response schemas. In case of authentication, for example, you can return:</p> <ul> <li>200 successful -&gt; token</li> <li>401 -&gt; Unauthorized</li> <li>402 -&gt; Payment required</li> <li>403 -&gt; Forbidden</li> <li>etc..</li> </ul> <p>In fact, the OpenAPI specification allows you to pass multiple response schemas.</p> <p>You can pass to a <code>response</code> argument a dictionary where:</p> <ul> <li>key is a response code</li> <li>value is a schema for that code</li> </ul> <p>Also, when you return the result - you have to also pass a status code to tell Django Ninja which schema should be used for validation and serialization.</p> <p>An example:</p> <pre><code>class Token(Schema):\n    token: str\n    expires: date\n\nclass Message(Schema):\n    message: str\n\n\n@api.post('/login', response={200: Token, 401: Message, 402: Message})\ndef login(request, payload: Auth):\n    if auth_not_valid:\n        return 401, {'message': 'Unauthorized'}\n    if negative_balance:\n        return 402, {'message': 'Insufficient balance amount. Please proceed to a payment page.'}\n    return 200, {'token': xxx, ...}\n</code></pre>"},{"location":"guides/response/#multiple-response-codes","title":"Multiple response codes","text":"<p>In the previous example you saw that we basically repeated the <code>Message</code> schema twice:</p> <pre><code>...401: Message, 402: Message}\n</code></pre> <p>To avoid this duplication you can use multiple response codes for a schema:</p> <pre><code>...\nfrom ninja.responses import codes_4xx\n\n\n@api.post('/login', response={200: Token, codes_4xx: Message})\ndef login(request, payload: Auth):\n    if auth_not_valid:\n        return 401, {'message': 'Unauthorized'}\n    if negative_balance:\n        return 402, {'message': 'Insufficient balance amount. Please proceed to a payment page.'}\n    return 200, {'token': xxx, ...}\n</code></pre> <p>Django Ninja comes with the following HTTP codes:</p> <pre><code>from ninja.responses import codes_1xx\nfrom ninja.responses import codes_2xx\nfrom ninja.responses import codes_3xx\nfrom ninja.responses import codes_4xx\nfrom ninja.responses import codes_5xx\n</code></pre> <p>You can also create your own range using a <code>frozenset</code>:</p> <pre><code>my_codes = frozenset({416, 418, 425, 429, 451})\n\n@api.post('/login', response={200: Token, my_codes: Message})\ndef login(request, payload: Auth):\n    ...\n</code></pre>"},{"location":"guides/response/#empty-responses","title":"Empty responses","text":"<p>Some responses, such as 204 No Content, have no body. To indicate the response body is empty mark <code>response</code> argument with <code>None</code> instead of Schema:</p> <pre><code>@api.post(\"/no_content\", response={204: None})\ndef no_content(request):\n    return 204, None\n</code></pre>"},{"location":"guides/response/#error-responses","title":"Error responses","text":"<p>Check Handling errors for more information.</p>"},{"location":"guides/response/#self-referencing-schemes","title":"Self-referencing schemes","text":"<p>Sometimes you need to create a schema that has reference to itself, or tree-structure objects.</p> <p>To do that you need:</p> <ul> <li>set a type of your schema in quotes</li> <li>use <code>model_rebuild</code> method to apply self referencing types</li> </ul> <pre><code>class Organization(Schema):\n    title: str\n    part_of: 'Organization' = None     #!! note the type in quotes here !!\n\n\nOrganization.model_rebuild()  # !!! this is important\n\n\n@api.get('/organizations', response=List[Organization])\ndef list_organizations(request):\n    ...\n</code></pre>"},{"location":"guides/response/#self-referencing-schemes-from-create_schema","title":"Self-referencing schemes from <code>create_schema()</code>","text":"<p>To be able to use the method <code>model_rebuild()</code> from a schema generated via <code>create_schema()</code>, the \"name\" of the class needs to be in our namespace. In this case it is very important to pass the <code>name</code> parameter to <code>create_schema()</code></p> <pre><code>UserSchema = create_schema(\n    User,\n    name='UserSchema',  # !!! this is important for model_rebuild()\n    fields=['id', 'username']\n    custom_fields=[\n        ('manager', 'UserSchema', None),\n    ]\n)\nUserSchema.model_rebuild()\n</code></pre>"},{"location":"guides/response/#serializing-outside-of-views","title":"Serializing Outside of Views","text":"<p>Serialization of your objects can be done directly in code through the use of the <code>.from_orm()</code> method on the schema object.</p> <p>Consider the following model:</p> <pre><code>class Person(models.Model):\n    name = models.CharField(max_length=50)\n</code></pre> <p>Which can be accessed using this schema:</p> <pre><code>class PersonSchema(Schema):\n    name: str\n</code></pre> <p>Direct serialization can be performed using the <code>.from_orm()</code> method on the schema. Once you have an instance of the schema object, the <code>.dict()</code> and <code>.json()</code> methods allow you to get at both dictionary output and string JSON versions.</p> <pre><code>&gt;&gt;&gt; person = Person.objects.get(id=1)\n&gt;&gt;&gt; data = PersonSchema.from_orm(person)\n&gt;&gt;&gt; data\nPersonSchema(id=1, name='Mr. Smith')\n&gt;&gt;&gt; data.dict()\n{'id':1, 'name':'Mr. Smith'}\n&gt;&gt;&gt; data.json()\n'{\"id\":1, \"name\":\"Mr. Smith\"}'\n</code></pre> <p>Multiple Items: or a queryset (or list)</p> <pre><code>&gt;&gt;&gt; persons = Person.objects.all()\n&gt;&gt;&gt; data = [PersonSchema.from_orm(i).dict() for i in persons]\n[{'id':1, 'name':'Mr. Smith'},{'id': 2, 'name': 'Mrs. Smith'}...]\n</code></pre>"},{"location":"guides/response/#django-http-responses","title":"Django HTTP responses","text":"<p>It is also possible to return regular django http responses:</p> <pre><code>from django.http import HttpResponse\nfrom django.shortcuts import redirect\n\n\n@api.get(\"/http\")\ndef result_django(request):\n    return HttpResponse('some data')   # !!!!\n\n\n@api.get(\"/something\")\ndef some_redirect(request):\n    return redirect(\"/some-path\")  # !!!!\n</code></pre>"},{"location":"guides/response/config-pydantic/","title":"Overriding Pydantic Config","text":"<p>There are many customizations available for a Django Ninja <code>Schema</code>, via the schema's Pydantic <code>Config</code> class. </p> <p>Info</p> <p>Under the hood Django Ninja uses Pydantic Models with all their power and benefits. The alias <code>Schema</code> was chosen to avoid confusion in code when using Django models, as Pydantic's model class is called Model by default, and conflicts with Django's Model class.</p>"},{"location":"guides/response/config-pydantic/#automatic-camel-case-aliases","title":"Automatic Camel Case Aliases","text":"<p>One useful <code>Config</code> attribute is <code>alias_generator</code>. We can use it to automatically generate aliases for field names with a given function. This is mostly commonly used to create an API that uses camelCase for its property names. Using Pydantic's example in Django Ninja can look something like:</p> <pre><code>from ninja import Schema\nfrom pydantic.alias_generators import to_camel\n\n\nclass CamelModelSchema(Schema):\n    str_field_name: str\n    float_field_name: float\n\n    class Config(Schema.Config):\n        alias_generator = to_camel\n</code></pre> <p>Note</p> <p>When overriding the schema's <code>Config</code>, it is necessary to inherit from the base <code>Schema.Config</code> class. </p> <p>To alias <code>ModelSchema</code>'s field names, you'll also need to set <code>populate_by_name</code> on the <code>Schema</code> config and  enable <code>by_alias</code> in all endpoints using the model.</p> <pre><code>class UserSchema(ModelSchema):\n    class Config(Schema.Config):\n        alias_generator = to_camel\n        populate_by_name = True  # !!!!!! &lt;--------\n\n    class Meta:\n        model = User\n        model_fields = [\"id\", \"email\", \"created_date\"]\n\n\n@api.get(\"/users\", response=list[UserSchema], by_alias=True) # !!!!!! &lt;-------- by_alias\ndef get_users(request):\n    return User.objects.all()\n</code></pre> <p>results:</p> <pre><code>[\n  {\n    \"id\": 1,\n    \"email\": \"tim@apple.com\",\n    \"createdDate\": \"2011-08-24\"\n  },\n  {\n    \"id\": 2,\n    \"email\": \"sarah@smith.com\",\n    \"createdDate\": \"2012-03-06\"\n  },\n  ...\n]\n</code></pre>"},{"location":"guides/response/config-pydantic/#custom-config-from-django-model","title":"Custom Config from Django Model","text":"<p>When using <code>create_schema</code>, the resulting schema can be used to build another class with a custom config like:</p> <pre><code>from django.contrib.auth.models import User\nfrom ninja.orm import create_schema\n\n\nBaseUserSchema = create_schema(User)\n\n\nclass UserSchema(BaseUserSchema):\n\n    class Config(BaseUserSchema.Config):\n        ...\n</code></pre>"},{"location":"guides/response/django-pydantic-create-schema/","title":"Using create_schema","text":"<p>Under the hood, <code>ModelSchema</code> uses the <code>create_schema</code> function. This is a more advanced (and less safe) method - please use it carefully.</p>"},{"location":"guides/response/django-pydantic-create-schema/#create_schema","title":"<code>create_schema</code>","text":"<p>Django Ninja comes with a helper function <code>create_schema</code>:</p> <pre><code>def create_schema(\n    model, # django model\n    name = \"\", # name for the generated class, if empty model names is used\n    depth = 0, # if &gt; 0 schema will also be created for the nested ForeignKeys and Many2Many (with the provided depth of lookup)\n    fields: list[str] = None, # if passed - ONLY these fields will added to schema\n    exclude: list[str] = None, # if passed - these fields will be excluded from schema\n    optional_fields: list[str] | str = None, # if passed - these fields will not be required on schema (use '__all__' to mark ALL fields required)\n    custom_fields: list[tuple(str, Any, Any)] = None, # if passed - this will override default field types (or add new fields)\n)\n</code></pre> <p>Take this example:</p> <pre><code>from django.contrib.auth.models import User\nfrom ninja.orm import create_schema\n\nUserSchema = create_schema(User)\n\n# Will create schema like this:\n# \n# class UserSchema(Schema):\n#     id: int\n#     username: str\n#     first_name: str\n#     last_name: str\n#     password: str\n#     last_login: datetime\n#     is_superuser: bool\n#     email: str\n#     ... and the rest\n</code></pre> <p>Warning</p> <p>By default <code>create_schema</code> builds a schema with ALL model fields. This can lead to accidental unwanted data exposure (like hashed password, in the above example).  Always use <code>fields</code> or <code>exclude</code> arguments to explicitly define list of attributes.</p>"},{"location":"guides/response/django-pydantic-create-schema/#using-fields","title":"Using <code>fields</code>","text":"<pre><code>UserSchema = create_schema(User, fields=['id', 'username'])\n\n# Will create schema like this:\n# \n# class UserSchema(Schema):\n#     id: int\n#     username: str\n</code></pre>"},{"location":"guides/response/django-pydantic-create-schema/#using-exclude","title":"Using <code>exclude</code>","text":"<pre><code>UserSchema = create_schema(User, exclude=[\n    'password', 'last_login', 'is_superuser', 'is_staff', 'groups', 'user_permissions']\n)\n\n# Will create schema without excluded fields:\n# \n# class UserSchema(Schema):\n#    id: int\n#    username: str\n#    first_name: str\n#    last_name: str\n#    email: str\n#    is_active: bool\n#    date_joined: datetime\n</code></pre>"},{"location":"guides/response/django-pydantic-create-schema/#using-depth","title":"Using <code>depth</code>","text":"<p>The <code>depth</code> argument allows you to introspect the Django model into the Related fields(ForeignKey, OneToOne, ManyToMany).</p> <pre><code>UserSchema = create_schema(User, depth=1, fields=['username', 'groups'])\n\n# Will create the following schema:\n#\n# class UserSchema(Schema):\n#    username: str\n#    groups: List[Group]\n</code></pre> <p>Note here that groups became a <code>List[Group]</code> - many2many field introspected 1 level deeper and created schema as well for group:</p> <pre><code>class Group(Schema):\n    id: int\n    name: str\n    permissions: List[int]\n</code></pre>"},{"location":"guides/response/django-pydantic/","title":"Schemas from Django models","text":"<p>Schemas are very useful to define your validation rules and responses, but sometimes you need to reflect your database models into schemas and keep changes in sync.</p>"},{"location":"guides/response/django-pydantic/#modelschema","title":"ModelSchema","text":"<p><code>ModelSchema</code> is a special base class that can automatically generate schemas from your models.</p> <p>All you need is to set <code>model</code> and <code>fields</code> attributes on your schema <code>Meta</code>:</p> <pre><code>from django.contrib.auth.models import User\nfrom ninja import ModelSchema\n\nclass UserSchema(ModelSchema):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'first_name', 'last_name']\n\n# Will create schema like this:\n# \n# class UserSchema(Schema):\n#     id: int\n#     username: str\n#     first_name: str\n#     last_name: str\n</code></pre>"},{"location":"guides/response/django-pydantic/#using-all-model-fields","title":"Using ALL model fields","text":"<p>To use all fields from a model - you can pass <code>__all__</code> to <code>fields</code>:</p> <pre><code>class UserSchema(ModelSchema):\n    class Meta:\n        model = User\n        fields = \"__all__\"\n</code></pre> <p>Warning</p> <p>Using all is not recommended.  This can lead to accidental unwanted data exposure (like hashed password, in the above example).  General advice - use <code>fields</code> to explicitly define list of fields that you want to be visible in API.</p>"},{"location":"guides/response/django-pydantic/#excluding-model-fields","title":"Excluding model fields","text":"<p>To use all fields except a few, you can use <code>exclude</code> configuration:</p> <pre><code>class UserSchema(ModelSchema):\n    class Meta:\n        model = User\n        exclude = ['password', 'last_login', 'user_permissions']\n\n# Will create schema like this:\n# \n# class UserSchema(Schema):\n#     id: int\n#     username: str\n#     first_name: str\n#     last_name: str\n#     email: str\n#     is_superuser: bool\n#     ... and the rest\n</code></pre>"},{"location":"guides/response/django-pydantic/#overriding-fields","title":"Overriding fields","text":"<p>To change default annotation for some field, or to add a new field, just use annotated attributes as usual. </p> <pre><code>class GroupSchema(ModelSchema):\n    class Meta:\n        model = Group\n        fields = ['id', 'name']\n\n\nclass UserSchema(ModelSchema):\n    groups: List[GroupSchema] = []\n\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'first_name', 'last_name']\n</code></pre>"},{"location":"guides/response/django-pydantic/#making-fields-optional","title":"Making fields optional","text":"<p>Pretty often for PATCH API operations you need to make all fields of your schema optional. To do that, you can use config fields_optional</p> <pre><code>class PatchGroupSchema(ModelSchema):\n    class Meta:\n        model = Group\n        fields = ['id', 'name', 'description'] # Note: all these fields are required on model level\n        fields_optional = '__all__'\n</code></pre> <p>Also, you can define a subset of optional fields instead of <code>__all__</code>:</p> <pre><code>     fields_optional = ['description']\n</code></pre> <p>When you process input data, you need to tell Pydantic to avoid setting undefined fields to <code>None</code>:</p> <pre><code>@api.patch(\"/patch/{pk}\")\ndef patch(request, pk: int, payload: PatchGroupSchema):\n\n    # Notice that we set exclude_unset=True\n    updated_fields = payload.dict(exclude_unset=True)\n\n    obj = MyModel.objects.get(pk=pk)\n\n    for attr, value in updated_fields.items():\n        setattr(obj, attr, value)\n\n    obj.save()\n</code></pre>"},{"location":"guides/response/django-pydantic/#custom-fields-types","title":"Custom fields types","text":"<p>For each Django field it encounters, <code>ModelSchema</code> uses the default <code>Field.get_internal_type</code> method to find the correct representation in Pydantic schema (python type). This process works fine for the built-in field types, but there are cases where the user wants to create or use a custom field, with its own mapping to python type. In this case you should use <code>register_field</code> method to tell django-ninja which type should this django field represent:</p> <pre><code># models.py\n\nclass MyModel(models.Modle):\n    embedding = pgvector.VectorField()\n\n# schemas.py\nfrom ninja.orm import register_field\n\nregister_field('VectorField', list[float])\n</code></pre>"},{"location":"guides/response/django-pydantic/#patchdict","title":"PatchDict","text":"<p>Another way to work with patch request data is a <code>PatchDict</code> container which allows you to make  a schema with all optional fields and get a dict with only fields that was provide</p> <pre><code>from ninja import PatchDict\n\nclass GroupSchema(Schema):\n    # You do not have to make fields optional it will be converted by PatchDict\n    name: str\n    description: str\n    due_date: date\n\n\n@api.patch(\"/patch/{pk}\")\ndef modify_data(request, pk: int, payload: PatchDict[GroupSchema]):\n    obj = MyModel.objects.get(pk=pk)\n\n    for attr, value in payload.items():\n        setattr(obj, attr, value)\n\n    obj.save()\n</code></pre> <p>in this example the <code>payload</code> argument will be a type of <code>dict</code> only fields that were passed in request and validated using <code>GroupSchema</code></p>"},{"location":"guides/response/django-pydantic/#choices-and-enums","title":"Choices and Enums","text":"<p>If you define a Model field with <code>.choices</code>, <code>ModelSchema</code> will automatically carry that into your schema.</p> <p>However, if you are reusing the enum in multiple places, or if you are working with auto-generated OpenAPI clients,  it may be useful to create enum objects that are reusable between schemas and fields.  Shinobi can directly carry over a <code>TextChoices</code> or <code>IntegerChoices</code> enum by adding the <code>ChoicesMixin</code> to it.</p> <p>Info</p> <p><code>ChoicesMixin</code> requires Django 5.0+ and Python 3.11+</p> <pre><code>from django.db import models\nfrom ninja import ModelSchema\nfrom ninja.enum import ChoicesMixin\n\nclass NumberEnum(ChoicesMixin, models.TextChoices):\n    ONE = \"ONE\", \"One\"\n    TWO = \"TWO\", \"Two\"\n    THREE = \"THREE\", \"Three\"\n\nclass MyModel(models.Model):\n    number = models.CharField(max_length=10, choices=NumberEnum)\n\nclass MySchema(ModelSchema):\n    class Meta:\n        model = MyModel\n        fields = [\"number\"]\n</code></pre> <p>Info</p> <p>Note that <code>choices</code> must be set to <code>NumberEnum</code>, not <code>NumberEnum.choices</code>.</p>"},{"location":"guides/response/pagination/","title":"Pagination","text":"<p>Django Ninja comes with a pagination support. This allows you to split large result sets into individual pages.</p> <p>To apply pagination to a function - just apply <code>paginate</code> decorator:</p> <pre><code>from ninja.pagination import paginate\n\n@api.get('/users', response=List[UserSchema])\n@paginate\ndef list_users(request):\n    return User.objects.all()\n</code></pre> <p>That's it!</p> <p>Now you can query users with <code>limit</code> and <code>offset</code> GET parameters</p> <pre><code>/api/users?limit=10&amp;offset=0\n</code></pre> <p>by default limit is set to <code>100</code> (you can change it in your settings.py using <code>NINJA_PAGINATION_PER_PAGE</code>)</p>"},{"location":"guides/response/pagination/#built-in-pagination-classes","title":"Built in Pagination Classes","text":""},{"location":"guides/response/pagination/#limitoffsetpagination-default","title":"LimitOffsetPagination (default)","text":"<p>This is the default pagination class (You can change it in your settings.py using <code>NINJA_PAGINATION_CLASS</code> path to a class)</p> <pre><code>from ninja.pagination import paginate, LimitOffsetPagination\n\n@api.get('/users', response=List[UserSchema])\n@paginate(LimitOffsetPagination)\ndef list_users(request):\n    return User.objects.all()\n</code></pre> <p>Example query: <pre><code>/api/users?limit=10&amp;offset=0\n</code></pre></p> <p>this class has two input parameters:</p> <ul> <li><code>limit</code> - defines a number of queryset on the page (default = 100, change in NINJA_PAGINATION_PER_PAGE)</li> <li><code>offset</code> - set's the page window offset (default: 0, indexing starts with 0)</li> </ul>"},{"location":"guides/response/pagination/#pagenumberpagination","title":"PageNumberPagination","text":"<pre><code>from ninja.pagination import paginate, PageNumberPagination\n\n@api.get('/users', response=List[UserSchema])\n@paginate(PageNumberPagination)\ndef list_users(request):\n    return User.objects.all()\n</code></pre> <p>Example query: <pre><code>/api/users?page=2\n</code></pre></p> <p>this class has one parameter <code>page</code> and outputs 100 queryset per page by default  (can be changed with settings.py)</p> <p>Page numbering start with 1</p> <p>you can also set custom page_size value individually per view:</p> <pre><code>@api.get(\"/users\")\n@paginate(PageNumberPagination, page_size=50)\ndef list_users(...\n</code></pre> <p>In addition to the <code>page</code> parameter, you can also use the <code>page_size</code> parameter to dynamically adjust the number of records displayed per page:</p> <p>Example query: <pre><code>/api/users?page=2&amp;page_size=20\n</code></pre></p> <p>This allows you to temporarily override the page size setting in your request. The request will use the specified <code>page_size</code> value if provided. Otherwise, it will use either the value specified in the decorator or the value from <code>PAGINATION_MAX_PER_PAGE_SIZE</code> in settings.py if no decorator value is set.</p>"},{"location":"guides/response/pagination/#accessing-paginator-parameters-in-view-function","title":"Accessing paginator parameters in view function","text":"<p>If you need access to <code>Input</code> parameters used for pagination in your view function - use <code>pass_parameter</code> argument</p> <p>In that case input data will be available in <code>**kwargs</code>:</p> <pre><code>@api.get(\"/someview\")\n@paginate(pass_parameter=\"pagination_info\")\ndef someview(request, **kwargs):\n    page = kwargs[\"pagination_info\"].page\n    return ...\n</code></pre>"},{"location":"guides/response/pagination/#creating-custom-pagination-class","title":"Creating Custom Pagination Class","text":"<p>To create a custom pagination class you should subclass <code>ninja.pagination.PaginationBase</code> and override the <code>Input</code> and <code>Output</code> schema classes and <code>paginate_queryset(self, queryset, request, **params)</code> method:</p> <ul> <li>The <code>Input</code> schema is a Schema class that describes parameters that should be passed to your paginator (f.e. page-number or limit/offset values).</li> <li>The <code>Output</code> schema describes schema for page output (f.e. count/next-page/items/etc).</li> <li>The <code>paginate_queryset</code> method is passed the initial queryset and should return an iterable object that contains only the data in the requested page. This method accepts the following arguments:<ul> <li><code>queryset</code>: a queryset (or iterable) returned by the api function</li> <li><code>pagination</code> - the paginator.Input parameters (parsed and validated)</li> <li><code>**params</code>: kwargs that will contain all the arguments that decorated function received </li> </ul> </li> </ul> <p>Example:</p> <pre><code>from ninja.pagination import paginate, PaginationBase\nfrom ninja import Schema\n\n\nclass CustomPagination(PaginationBase):\n    # only `skip` param, defaults to 5 per page\n    class Input(Schema):\n        skip: int\n\n\n    class Output(Schema):\n        items: List[Any] # `items` is a default attribute\n        total: int\n        per_page: int\n\n    def paginate_queryset(self, queryset, pagination: Input, **params):\n        skip = pagination.skip\n        return {\n            'items': queryset[skip : skip + 5],\n            'total': queryset.count(),\n            'per_page': 5,\n        }\n\n\n@api.get('/users', response=List[UserSchema])\n@paginate(CustomPagination)\ndef list_users(request):\n    return User.objects.all()\n</code></pre> <p>Tip: You can access request object from params:</p> <pre><code>def paginate_queryset(self, queryset, pagination: Input, **params):\n    request = params[\"request\"]\n</code></pre>"},{"location":"guides/response/pagination/#async-pagination","title":"Async Pagination","text":"<p>Standard Django Ninja pagination classes support async. If you wish to handle async requests with a custom pagination class, you should subclass <code>ninja.pagination.AsyncPaginationBase</code> and override the <code>apaginate_queryset(self, queryset, request, **params)</code> method.</p>"},{"location":"guides/response/pagination/#output-attribute","title":"Output attribute","text":"<p>By default page items are placed to <code>'items'</code> attribute. To override this behaviour use <code>items_attribute</code>:</p> <pre><code>class CustomPagination(PaginationBase):\n    ...\n    class Output(Schema):\n        results: List[Any]\n        total: int\n        per_page: int\n\n    items_attribute: str = \"results\"\n</code></pre>"},{"location":"guides/response/pagination/#apply-pagination-to-multiple-operations-at-once","title":"Apply pagination to multiple operations at once","text":"<p>There is often a case when you need to add pagination to all views that returns querysets or list</p> <p>You can use a builtin router class (<code>RouterPaginated</code>) that automatically injects pagination to all operations that defined <code>response=List[SomeSchema]</code>:</p> <pre><code>from ninja.pagination import RouterPaginated\n\nrouter = RouterPaginated()\n\n\n@router.get(\"/items\", response=List[MySchema])\ndef items(request):\n    return MyModel.objects.all()\n\n@router.get(\"/other-items\", response=List[OtherSchema])\ndef other_items(request):\n    return OtherModel.objects.all()\n</code></pre> <p>In this example both operations will have pagination enabled</p> <p>to apply pagination to main <code>api</code> instance use <code>default_router</code> argument:</p> <pre><code>api = NinjaAPI(default_router=RouterPaginated())\n\n@api.get(...\n</code></pre>"},{"location":"guides/response/response-renderers/","title":"Response renderers","text":"<p>The most common response type for a REST API is usually JSON. Django Ninja also has support for defining your own custom renderers, which gives you the flexibility to design your own media types.</p>"},{"location":"guides/response/response-renderers/#create-a-renderer","title":"Create a renderer","text":"<p>To create your own renderer, you need to inherit <code>ninja.renderers.BaseRenderer</code> and override the <code>render</code> method. Then you can pass an instance of your class to <code>NinjaAPI</code> as the <code>renderer</code> argument:</p> <pre><code>from ninja import NinjaAPI\nfrom ninja.renderers import BaseRenderer\n\n\nclass MyRenderer(BaseRenderer):\n    media_type = \"text/plain\"\n\n    def render(self, request, data, *, response_status):\n        return ... # your serialization here\n\napi = NinjaAPI(renderer=MyRenderer())\n</code></pre> <p>The <code>render</code> method takes the following arguments:</p> <ul> <li>request -&gt; HttpRequest object </li> <li>data -&gt; object that needs to be serialized</li> <li>response_status as an <code>int</code> -&gt; the HTTP status code that will be returned to the client</li> </ul> <p>You need also define the <code>media_type</code> attribute on the class to set the content-type header for the response.</p>"},{"location":"guides/response/response-renderers/#orjson-renderer-example","title":"ORJSON renderer example:","text":"<p>orjson is a fast, accurate JSON library for Python. It benchmarks as the fastest Python library for JSON and is more accurate than the standard <code>json</code> library or other third-party libraries. It also serializes dataclass, datetime, numpy, and UUID instances natively.</p> <p>Here's an example renderer class that uses <code>orjson</code>:</p> <pre><code>import orjson\nfrom ninja import NinjaAPI\nfrom ninja.renderers import BaseRenderer\n\n\nclass ORJSONRenderer(BaseRenderer):\n    media_type = \"application/json\"\n\n    def render(self, request, data, *, response_status):\n        return orjson.dumps(data)\n\napi = NinjaAPI(renderer=ORJSONRenderer())\n</code></pre>"},{"location":"guides/response/response-renderers/#xml-renderer-example","title":"XML renderer example:","text":"<p>This is how you create a renderer that outputs all responses as XML:</p> <p><pre><code>from io import StringIO\nfrom django.utils.encoding import force_str\nfrom django.utils.xmlutils import SimplerXMLGenerator\nfrom ninja import NinjaAPI\nfrom ninja.renderers import BaseRenderer\n\n\nclass XMLRenderer(BaseRenderer):\n    media_type = \"text/xml\"\n\n    def render(self, request, data, *, response_status):\n        stream = StringIO()\n        xml = SimplerXMLGenerator(stream, \"utf-8\")\n        xml.startDocument()\n        xml.startElement(\"data\", {})\n        self._to_xml(xml, data)\n        xml.endElement(\"data\")\n        xml.endDocument()\n        return stream.getvalue()\n\n    def _to_xml(self, xml, data):\n        if isinstance(data, (list, tuple)):\n            for item in data:\n                xml.startElement(\"item\", {})\n                self._to_xml(xml, item)\n                xml.endElement(\"item\")\n\n        elif isinstance(data, dict):\n            for key, value in data.items():\n                xml.startElement(key, {})\n                self._to_xml(xml, value)\n                xml.endElement(key)\n\n        elif data is None:\n            # Don't output any value\n            pass\n\n        else:\n            xml.characters(force_str(data))\n\n\napi = NinjaAPI(renderer=XMLRenderer())\n</code></pre> (Copyright note: this code is basically copied from DRF-xml)</p>"},{"location":"guides/response/temporal_response/","title":"Altering the Response","text":"<p>Sometimes you'll want to change the response just before it gets served, for example, to add a header or alter a cookie.</p> <p>To do this, simply declare a function parameter with a type of <code>HttpResponse</code>:</p> <pre><code>from django.http import HttpRequest, HttpResponse\n\n@api.get(\"/cookie/\")\ndef feed_cookiemonster(request: HttpRequest, response: HttpResponse):\n    # Set a cookie.\n    response.set_cookie(\"cookie\", \"delicious\")\n    # Set a header.\n    response[\"X-Cookiemonster\"] = \"blue\"\n    return {\"cookiemonster_happy\": True}\n</code></pre>"},{"location":"guides/response/temporal_response/#temporal-response-object","title":"Temporal response object","text":"<p>This response object is used for the base of all responses built by Django Ninja, including error responses. This object is not used if a Django <code>HttpResponse</code> object is returned directly by an operation.</p> <p>Obviously this response object won't contain the content yet, but it does have the <code>content_type</code> set (but you probably don't want to be changing it).</p> <p>The <code>status_code</code> will get overridden depending on the return value (200 by default, or the status code if a two-part tuple is returned).</p>"},{"location":"guides/response/temporal_response/#changing-the-base-response-object","title":"Changing the base response object","text":"<p>You can alter this temporal response object by overriding the <code>NinjaAPI.create_temporal_response</code> method.</p> <pre><code>    def create_temporal_response(self, request: HttpRequest) -&gt; HttpResponse:\n        response = super().create_temporal_response(request)\n        # Do your magic here...\n        return response\n</code></pre>"},{"location":"proposals/","title":"Enhancement Proposals","text":"<p>Enhancement Proposals are a formal way of proposing large feature additions to the Django Ninja Framework.</p> <p>You can create a proposal by making a pull request with a new page under <code>docs/proposals</code>, or by creating an issue on github.</p> <p>Please see the current proposals:</p> <ul> <li>Class Based Operations</li> </ul>"},{"location":"proposals/cbv/","title":"Class Based Operations","text":"<p>This is just a proposal and it is not present in library code, but eventually this can be a part of Django Ninja.</p> <p>Please consider adding likes/dislikes or comments in github issue to express your feeling about this proposal</p>"},{"location":"proposals/cbv/#problem","title":"Problem","text":"<p>An API operation is a callable which takes a request and parameters and returns a response, but it is often a case in real world when you need to reuse the same pieces of code in multiple operations.</p> <p>Let's take the following example:</p> <ul> <li>we have a Todo application with Projects and Tasks</li> <li>each project has multiple tasks</li> <li>each project may also have an owner (user)</li> <li>users should not be able to access projects they do not own</li> </ul> <p>Model structure is something like this:</p> <pre><code>class Project(models.Model):\n    title = models.CharField(max_length=100)\n    owner = models.ForeignKey('auth.User', on_delete=models.CASCADE)\n\nclass Task(models.Model):\n    project = models.ForeignKey(Project, on_delete=models.CASCADE)\n    title = models.CharField(max_length=100)\n    completed = models.BooleanField()\n</code></pre> <p>Now, let's create a few API operations for it:</p> <ul> <li>a list of tasks for the project</li> <li>some task details</li> <li>a 'complete task' action</li> </ul> <p>The code should validate that a user can only access his/her own project's tasks (otherwise, return 404)</p> <p>It can be something like this:</p> <pre><code>router = Router()\n\n@router.get('/project/{project_id}/tasks/', response=List[TaskOut])\ndef task_list(request):\n    user_projects = request.user.project_set\n    project = get_object_or_404(user_projects, id=project_id))\n    return project.task_set.all()\n\n@router.get('/project/{project_id}/tasks/{task_id}/', response=TaskOut)\ndef details(request, task_id: int):\n    user_projects = request.user.project_set\n    project = get_object_or_404(user_projects, id=project_id))\n    user_tasks = project.task_set.all()\n    return get_object_or_404(user_tasks, id=task_id)\n\n\n@router.post('/project/{project_id}/tasks/{task_id}/complete', response=TaskOut)\ndef complete(request, task_id: int):\n    user_projects = request.user.project_set\n    project = get_object_or_404(user_projects, id=project_id))\n    user_tasks = project.task_set.all()\n    task = get_object_or_404(user_tasks, id=task_id)\n    task.completed = True\n    task.save()\n    return task\n</code></pre> <p>As you can see, these lines are getting repeated pretty often to check permission:</p> <pre><code>user_projects = request.user.project_set\nproject = get_object_or_404(user_projects, id=project_id))\n</code></pre> <p>You can extract it to a function, but it will just make it 3 lines smaller, and it will still be pretty polluted ...</p>"},{"location":"proposals/cbv/#solution","title":"Solution","text":"<p>The proposal is to have alternative called \"Class Based Operation\" where you can decorate the entire class with a <code>path</code> decorator:</p> <pre><code>from ninja import Router\n\n\nrouter = Router()\n\n\n@router.path('/project/{project_id}/tasks')\nclass Tasks:\n    def __init__(self, request, project_id=int):\n        user_projects = request.user.project_set\n        self.project = get_object_or_404(user_projects, id=project_id))\n        self.tasks = self.project.task_set.all()\n\n    @router.get('/', response=List[TaskOut])\n    def task_list(self, request):\n        return self.tasks\n\n    @router.get('/{task_id}/', response=TaskOut)\n    def details(self, request, task_id: int):\n        return get_object_or_404(self.tasks, id=task_id)\n\n    @router.post('/{task_id}/complete', response=TaskOut)\n    def complete(self, request, task_id: int):\n        task = get_object_or_404(self.tasks, id=task_id)\n        task.completed = True\n        task.save()\n        return task\n</code></pre> <p>All common initiation and permission checks are placed in the constructor:</p> <pre><code>@router.path('/project/{project_id}/tasks')\nclass Tasks:\n    def __init__(self, request, project_id=int):\n        user_projects = request.user.project_set\n        self.project = get_object_or_404(user_projects, id=project_id))\n        self.tasks = self.project.task_set.all()\n</code></pre> <p>This makes the main business operation focus only on tasks (exposed as the <code>self.tasks</code> attribute)</p> <p>You can use both <code>api</code> and <code>router</code> instances to support class paths.</p>"},{"location":"proposals/cbv/#issue","title":"Issue","text":"<p>The <code>__init__</code> method:</p> <p><code>def __init__(self, request, project_id=int):</code></p> <p>Python doesn't support the <code>async</code> keyword for <code>__init__</code>, so to support async operations we need some other method for initialization, but <code>__init__</code> sounds the most logical.</p>"},{"location":"proposals/cbv/#your-thoughtsproposals","title":"Your thoughts/proposals","text":"<p>Please give you thoughts/likes/dislikes about this proposal in the github issue</p>"},{"location":"proposals/v1/","title":"Potential v1 changes","text":"<p>Django Ninja is already used by tens of companies and by the visitors and downloads stats it's growing.</p> <p>At this point introducing changes that will force current users to change their code (or break it) is not  acceptable.</p> <p>On the other hand some decisions that where initially made does not work well. These  breaking changes will be  introduced in version 1.0.0</p>"},{"location":"proposals/v1/#changes-that-most-likely-be-in-v1","title":"Changes that most likely be in v1","text":"<ul> <li>auth will be class interface instead of callable (to support async authenticators)</li> <li>responses to support codes/headers/content (like general Response class)</li> <li>routers paths currently automatically joined with \"/\" - which might not needed on some cases where router prefix will act like a prefix and not subfolder</li> </ul>"},{"location":"proposals/v1/#your-thoughtsproposals","title":"Your thoughts/proposals","text":"<p>Please give you thoughts/likes/dislikes in the github issue.</p>"},{"location":"reference/api/","title":"NinjaAPI","text":"<p>Ninja API</p> Source code in <code>ninja/main.py</code> <pre><code>class NinjaAPI:\n    \"\"\"\n    Ninja API\n    \"\"\"\n\n    _registry: List[str] = []\n\n    def __init__(\n        self,\n        *,\n        title: str = \"NinjaAPI\",\n        version: str = \"1.0.0\",\n        description: str = \"\",\n        openapi_url: Optional[str] = \"/openapi.json\",\n        docs: DocsBase = Swagger(),\n        docs_url: Optional[str] = \"/docs\",\n        docs_decorator: Optional[Callable[[TCallable], TCallable]] = None,\n        servers: Optional[List[DictStrAny]] = None,\n        urls_namespace: Optional[str] = None,\n        csrf: bool = False,\n        auth: Optional[Union[Sequence[Callable], Callable, NOT_SET_TYPE]] = NOT_SET,\n        throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n        renderer: Optional[BaseRenderer] = None,\n        parser: Optional[Parser] = None,\n        default_router: Optional[Router] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Args:\n            title: A title for the api.\n            description: A description for the api.\n            version: The API version.\n            urls_namespace: The Django URL namespace for the API. If not provided, the namespace will be ``\"api-\" + self.version``.\n            openapi_url: The relative URL to serve the openAPI spec.\n            openapi_extra: Additional attributes for the openAPI spec.\n            docs_url: The relative URL to serve the API docs.\n            servers: List of target hosts used in openAPI spec.\n            csrf: Require a CSRF token for unsafe request types. See &lt;a href=\"../csrf\"&gt;CSRF&lt;/a&gt; docs.\n            auth (Callable | Sequence[Callable] | NOT_SET | None): Authentication class\n            renderer: Default response renderer\n            parser: Default request parser\n        \"\"\"\n        self.title = title\n        self.version = version\n        self.description = description\n        self.openapi_url = openapi_url\n        self.docs = docs\n        self.docs_url = docs_url\n        self.docs_decorator = docs_decorator\n        self.servers = servers or []\n        self.urls_namespace = urls_namespace or f\"api-{self.version}\"\n        self.csrf = csrf  # TODO: Check if used or at least throw Deprecation warning\n        if self.csrf:\n            warnings.warn(\n                \"csrf argument is deprecated, auth is handling csrf automatically now\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        self.renderer = renderer or JSONRenderer()\n        self.parser = parser or Parser()\n        self.openapi_extra = openapi_extra or {}\n\n        self._exception_handlers: Dict[Exc, ExcHandler] = {}\n        self.set_default_exception_handlers()\n\n        self.auth: Optional[Union[Sequence[Callable], NOT_SET_TYPE]]\n\n        if callable(auth):\n            self.auth = [auth]\n        else:\n            self.auth = auth\n\n        self.throttle = throttle\n\n        self._routers: List[Tuple[str, Router]] = []\n        self.default_router = default_router or Router()\n        self.add_router(\"\", self.default_router)\n\n    def get(\n        self,\n        path: str,\n        *,\n        auth: Any = NOT_SET,\n        throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n        response: Any = NOT_SET,\n        operation_id: Optional[str] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        tags: Optional[List[str]] = None,\n        deprecated: Optional[bool] = None,\n        by_alias: Optional[bool] = None,\n        exclude_unset: Optional[bool] = None,\n        exclude_defaults: Optional[bool] = None,\n        exclude_none: Optional[bool] = None,\n        url_name: Optional[str] = None,\n        include_in_schema: bool = True,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -&gt; Callable[[TCallable], TCallable]:\n        \"\"\"\n        `GET` operation. See &lt;a href=\"../operations-parameters\"&gt;operations\n        parameters&lt;/a&gt; reference.\n        \"\"\"\n        return self.default_router.get(\n            path,\n            auth=auth is NOT_SET and self.auth or auth,\n            throttle=throttle is NOT_SET and self.throttle or throttle,\n            response=response,\n            operation_id=operation_id,\n            summary=summary,\n            description=description,\n            tags=tags,\n            deprecated=deprecated,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            url_name=url_name,\n            include_in_schema=include_in_schema,\n            openapi_extra=openapi_extra,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        auth: Any = NOT_SET,\n        throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n        response: Any = NOT_SET,\n        operation_id: Optional[str] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        tags: Optional[List[str]] = None,\n        deprecated: Optional[bool] = None,\n        by_alias: Optional[bool] = None,\n        exclude_unset: Optional[bool] = None,\n        exclude_defaults: Optional[bool] = None,\n        exclude_none: Optional[bool] = None,\n        url_name: Optional[str] = None,\n        include_in_schema: bool = True,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -&gt; Callable[[TCallable], TCallable]:\n        \"\"\"\n        `POST` operation. See &lt;a href=\"../operations-parameters\"&gt;operations\n        parameters&lt;/a&gt; reference.\n        \"\"\"\n        return self.default_router.post(\n            path,\n            auth=auth is NOT_SET and self.auth or auth,\n            throttle=throttle is NOT_SET and self.throttle or throttle,\n            response=response,\n            operation_id=operation_id,\n            summary=summary,\n            description=description,\n            tags=tags,\n            deprecated=deprecated,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            url_name=url_name,\n            include_in_schema=include_in_schema,\n            openapi_extra=openapi_extra,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        auth: Any = NOT_SET,\n        throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n        response: Any = NOT_SET,\n        operation_id: Optional[str] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        tags: Optional[List[str]] = None,\n        deprecated: Optional[bool] = None,\n        by_alias: Optional[bool] = None,\n        exclude_unset: Optional[bool] = None,\n        exclude_defaults: Optional[bool] = None,\n        exclude_none: Optional[bool] = None,\n        url_name: Optional[str] = None,\n        include_in_schema: bool = True,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -&gt; Callable[[TCallable], TCallable]:\n        \"\"\"\n        `DELETE` operation. See &lt;a href=\"../operations-parameters\"&gt;operations\n        parameters&lt;/a&gt; reference.\n        \"\"\"\n        return self.default_router.delete(\n            path,\n            auth=auth is NOT_SET and self.auth or auth,\n            throttle=throttle is NOT_SET and self.throttle or throttle,\n            response=response,\n            operation_id=operation_id,\n            summary=summary,\n            description=description,\n            tags=tags,\n            deprecated=deprecated,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            url_name=url_name,\n            include_in_schema=include_in_schema,\n            openapi_extra=openapi_extra,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        auth: Any = NOT_SET,\n        throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n        response: Any = NOT_SET,\n        operation_id: Optional[str] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        tags: Optional[List[str]] = None,\n        deprecated: Optional[bool] = None,\n        by_alias: Optional[bool] = None,\n        exclude_unset: Optional[bool] = None,\n        exclude_defaults: Optional[bool] = None,\n        exclude_none: Optional[bool] = None,\n        url_name: Optional[str] = None,\n        include_in_schema: bool = True,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -&gt; Callable[[TCallable], TCallable]:\n        \"\"\"\n        `PATCH` operation. See &lt;a href=\"../operations-parameters\"&gt;operations\n        parameters&lt;/a&gt; reference.\n        \"\"\"\n        return self.default_router.patch(\n            path,\n            auth=auth is NOT_SET and self.auth or auth,\n            throttle=throttle is NOT_SET and self.throttle or throttle,\n            response=response,\n            operation_id=operation_id,\n            summary=summary,\n            description=description,\n            tags=tags,\n            deprecated=deprecated,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            url_name=url_name,\n            include_in_schema=include_in_schema,\n            openapi_extra=openapi_extra,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        auth: Any = NOT_SET,\n        throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n        response: Any = NOT_SET,\n        operation_id: Optional[str] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        tags: Optional[List[str]] = None,\n        deprecated: Optional[bool] = None,\n        by_alias: Optional[bool] = None,\n        exclude_unset: Optional[bool] = None,\n        exclude_defaults: Optional[bool] = None,\n        exclude_none: Optional[bool] = None,\n        url_name: Optional[str] = None,\n        include_in_schema: bool = True,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -&gt; Callable[[TCallable], TCallable]:\n        \"\"\"\n        `PUT` operation. See &lt;a href=\"../operations-parameters\"&gt;operations\n        parameters&lt;/a&gt; reference.\n        \"\"\"\n        return self.default_router.put(\n            path,\n            auth=auth is NOT_SET and self.auth or auth,\n            throttle=throttle is NOT_SET and self.throttle or throttle,\n            response=response,\n            operation_id=operation_id,\n            summary=summary,\n            description=description,\n            tags=tags,\n            deprecated=deprecated,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            url_name=url_name,\n            include_in_schema=include_in_schema,\n            openapi_extra=openapi_extra,\n        )\n\n    def api_operation(\n        self,\n        methods: List[str],\n        path: str,\n        *,\n        auth: Any = NOT_SET,\n        throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n        response: Any = NOT_SET,\n        operation_id: Optional[str] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        tags: Optional[List[str]] = None,\n        deprecated: Optional[bool] = None,\n        by_alias: Optional[bool] = None,\n        exclude_unset: Optional[bool] = None,\n        exclude_defaults: Optional[bool] = None,\n        exclude_none: Optional[bool] = None,\n        url_name: Optional[str] = None,\n        include_in_schema: bool = True,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -&gt; Callable[[TCallable], TCallable]:\n        return self.default_router.api_operation(\n            methods,\n            path,\n            auth=auth is NOT_SET and self.auth or auth,\n            throttle=throttle is NOT_SET and self.throttle or throttle,\n            response=response,\n            operation_id=operation_id,\n            summary=summary,\n            description=description,\n            tags=tags,\n            deprecated=deprecated,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            url_name=url_name,\n            include_in_schema=include_in_schema,\n            openapi_extra=openapi_extra,\n        )\n\n    def add_router(\n        self,\n        prefix: str,\n        router: Union[Router, str],\n        *,\n        auth: Any = NOT_SET,\n        throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n        tags: Optional[List[str]] = None,\n        parent_router: Optional[Router] = None,\n    ) -&gt; None:\n        if isinstance(router, str):\n            router = import_string(router)\n            assert isinstance(router, Router)\n\n        if auth is not NOT_SET:\n            router.auth = auth\n\n        if throttle is not NOT_SET:\n            router.throttle = throttle\n\n        if tags is not None:\n            router.tags = tags\n\n        if parent_router:\n            parent_prefix = next(\n                (path for path, r in self._routers if r is parent_router), None\n            )  # pragma: no cover\n            assert parent_prefix is not None\n            prefix = normalize_path(\"/\".join((parent_prefix, prefix))).lstrip(\"/\")\n\n        self._routers.extend(router.build_routers(prefix))\n        router.set_api_instance(self, parent_router)\n\n    @property\n    def urls(self) -&gt; Tuple[List[Union[URLResolver, URLPattern]], str, str]:\n        \"\"\"\n        str: URL configuration\n\n        Returns:\n\n            Django URL configuration\n        \"\"\"\n        self._validate()\n        return (\n            self._get_urls(),\n            \"ninja\",\n            self.urls_namespace.split(\":\")[-1],\n            # ^ if api included into nested urls, we only care about last bit here\n        )\n\n    def _get_urls(self) -&gt; List[Union[URLResolver, URLPattern]]:\n        result = get_openapi_urls(self)\n\n        for prefix, router in self._routers:\n            result.extend(router.urls_paths(prefix))\n\n        result.append(get_root_url(self))\n        return result\n\n    def get_root_path(self, path_params: DictStrAny) -&gt; str:\n        name = f\"{self.urls_namespace}:api-root\"\n        return reverse(name, kwargs=path_params)\n\n    def create_response(\n        self,\n        request: HttpRequest,\n        data: Any,\n        *,\n        status: Optional[int] = None,\n        temporal_response: Optional[HttpResponse] = None,\n    ) -&gt; HttpResponse:\n        if temporal_response:\n            status = temporal_response.status_code\n        assert status\n\n        content = self.renderer.render(request, data, response_status=status)\n\n        if temporal_response:\n            response = temporal_response\n            response.content = content\n        else:\n            response = HttpResponse(\n                content, status=status, content_type=self.get_content_type()\n            )\n\n        return response\n\n    def create_temporal_response(self, request: HttpRequest) -&gt; HttpResponse:\n        return HttpResponse(\"\", content_type=self.get_content_type())\n\n    def get_content_type(self) -&gt; str:\n        return f\"{self.renderer.media_type}; charset={self.renderer.charset}\"\n\n    def get_openapi_schema(\n        self,\n        *,\n        path_prefix: Optional[str] = None,\n        path_params: Optional[DictStrAny] = None,\n    ) -&gt; OpenAPISchema:\n        if path_prefix is None:\n            path_prefix = self.get_root_path(path_params or {})\n        return get_schema(api=self, path_prefix=path_prefix)\n\n    def get_openapi_operation_id(self, operation: \"Operation\") -&gt; str:\n        name = operation.view_func.__name__\n        module = operation.view_func.__module__\n        return (module + \"_\" + name).replace(\".\", \"_\")\n\n    def get_operation_url_name(self, operation: \"Operation\", router: Router) -&gt; str:\n        \"\"\"\n        Get the default URL name to use for an operation if it wasn't\n        explicitly provided.\n        \"\"\"\n        return operation.view_func.__name__\n\n    def add_exception_handler(\n        self, exc_class: Type[_E], handler: ExcHandler[_E]\n    ) -&gt; None:\n        assert issubclass(exc_class, Exception)\n        self._exception_handlers[exc_class] = handler\n\n    def exception_handler(\n        self, exc_class: Type[Exception]\n    ) -&gt; Callable[[TCallable], TCallable]:\n        def decorator(func: TCallable) -&gt; TCallable:\n            self.add_exception_handler(exc_class, func)\n            return func\n\n        return decorator\n\n    def set_default_exception_handlers(self) -&gt; None:\n        set_default_exc_handlers(self)\n\n    def on_exception(self, request: HttpRequest, exc: Exc[_E]) -&gt; HttpResponse:\n        handler = self._lookup_exception_handler(exc)\n        if handler is None:\n            raise exc\n        return handler(request, exc)\n\n    def validation_error_from_error_contexts(\n        self, error_contexts: List[ValidationErrorContext]\n    ) -&gt; ValidationError:\n        errors: List[Dict[str, Any]] = []\n        for context in error_contexts:\n            model = context.model\n            e = context.pydantic_validation_error\n            for i in e.errors(include_url=False):\n                i[\"loc\"] = (\n                    model.__ninja_param_source__,\n                ) + model.__ninja_flatten_map_reverse__.get(i[\"loc\"], i[\"loc\"])\n                # removing pydantic hints\n                del i[\"input\"]  # type: ignore\n                if (\n                    \"ctx\" in i\n                    and \"error\" in i[\"ctx\"]\n                    and isinstance(i[\"ctx\"][\"error\"], Exception)\n                ):\n                    i[\"ctx\"][\"error\"] = str(i[\"ctx\"][\"error\"])\n                errors.append(dict(i))\n        return ValidationError(errors)\n\n    def _lookup_exception_handler(self, exc: Exc[_E]) -&gt; Optional[ExcHandler[_E]]:\n        for cls in type(exc).__mro__:\n            if cls in self._exception_handlers:\n                return self._exception_handlers[cls]\n\n        return None\n\n    def _validate(self) -&gt; None:\n        # urls namespacing validation\n        skip_registry = os.environ.get(\"NINJA_SKIP_REGISTRY\", False)\n        if (\n            not skip_registry\n            and self.urls_namespace in NinjaAPI._registry\n            and not debug_server_url_reimport()\n        ):\n            msg = f\"\"\"\nLooks like you created multiple NinjaAPIs or TestClients\nTo let ninja distinguish them you need to set either unique version or urls_namespace\n - NinjaAPI(..., version='2.0.0')\n - NinjaAPI(..., urls_namespace='otherapi')\nAlready registered: {NinjaAPI._registry}\n\"\"\"\n            raise ConfigError(msg.strip())\n        NinjaAPI._registry.append(self.urls_namespace)\n</code></pre>"},{"location":"reference/api/#ninja.main.NinjaAPI.urls","title":"<code>urls: Tuple[List[Union[URLResolver, URLPattern]], str, str]</code>  <code>property</code>","text":"<p>str: URL configuration</p> <p>Returns:</p> <pre><code>Django URL configuration\n</code></pre>"},{"location":"reference/api/#ninja.main.NinjaAPI.__init__","title":"<code>__init__(*, title='NinjaAPI', version='1.0.0', description='', openapi_url='/openapi.json', docs=Swagger(), docs_url='/docs', docs_decorator=None, servers=None, urls_namespace=None, csrf=False, auth=NOT_SET, throttle=NOT_SET, renderer=None, parser=None, default_router=None, openapi_extra=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>A title for the api.</p> <code>'NinjaAPI'</code> <code>description</code> <code>str</code> <p>A description for the api.</p> <code>''</code> <code>version</code> <code>str</code> <p>The API version.</p> <code>'1.0.0'</code> <code>urls_namespace</code> <code>Optional[str]</code> <p>The Django URL namespace for the API. If not provided, the namespace will be <code>\"api-\" + self.version</code>.</p> <code>None</code> <code>openapi_url</code> <code>Optional[str]</code> <p>The relative URL to serve the openAPI spec.</p> <code>'/openapi.json'</code> <code>openapi_extra</code> <code>Optional[Dict[str, Any]]</code> <p>Additional attributes for the openAPI spec.</p> <code>None</code> <code>docs_url</code> <code>Optional[str]</code> <p>The relative URL to serve the API docs.</p> <code>'/docs'</code> <code>servers</code> <code>Optional[List[DictStrAny]]</code> <p>List of target hosts used in openAPI spec.</p> <code>None</code> <code>csrf</code> <code>bool</code> <p>Require a CSRF token for unsafe request types. See CSRF docs.</p> <code>False</code> <code>auth</code> <code>Callable | Sequence[Callable] | NOT_SET | None</code> <p>Authentication class</p> <code>NOT_SET</code> <code>renderer</code> <code>Optional[BaseRenderer]</code> <p>Default response renderer</p> <code>None</code> <code>parser</code> <code>Optional[Parser]</code> <p>Default request parser</p> <code>None</code> Source code in <code>ninja/main.py</code> <pre><code>def __init__(\n    self,\n    *,\n    title: str = \"NinjaAPI\",\n    version: str = \"1.0.0\",\n    description: str = \"\",\n    openapi_url: Optional[str] = \"/openapi.json\",\n    docs: DocsBase = Swagger(),\n    docs_url: Optional[str] = \"/docs\",\n    docs_decorator: Optional[Callable[[TCallable], TCallable]] = None,\n    servers: Optional[List[DictStrAny]] = None,\n    urls_namespace: Optional[str] = None,\n    csrf: bool = False,\n    auth: Optional[Union[Sequence[Callable], Callable, NOT_SET_TYPE]] = NOT_SET,\n    throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n    renderer: Optional[BaseRenderer] = None,\n    parser: Optional[Parser] = None,\n    default_router: Optional[Router] = None,\n    openapi_extra: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"\n    Args:\n        title: A title for the api.\n        description: A description for the api.\n        version: The API version.\n        urls_namespace: The Django URL namespace for the API. If not provided, the namespace will be ``\"api-\" + self.version``.\n        openapi_url: The relative URL to serve the openAPI spec.\n        openapi_extra: Additional attributes for the openAPI spec.\n        docs_url: The relative URL to serve the API docs.\n        servers: List of target hosts used in openAPI spec.\n        csrf: Require a CSRF token for unsafe request types. See &lt;a href=\"../csrf\"&gt;CSRF&lt;/a&gt; docs.\n        auth (Callable | Sequence[Callable] | NOT_SET | None): Authentication class\n        renderer: Default response renderer\n        parser: Default request parser\n    \"\"\"\n    self.title = title\n    self.version = version\n    self.description = description\n    self.openapi_url = openapi_url\n    self.docs = docs\n    self.docs_url = docs_url\n    self.docs_decorator = docs_decorator\n    self.servers = servers or []\n    self.urls_namespace = urls_namespace or f\"api-{self.version}\"\n    self.csrf = csrf  # TODO: Check if used or at least throw Deprecation warning\n    if self.csrf:\n        warnings.warn(\n            \"csrf argument is deprecated, auth is handling csrf automatically now\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    self.renderer = renderer or JSONRenderer()\n    self.parser = parser or Parser()\n    self.openapi_extra = openapi_extra or {}\n\n    self._exception_handlers: Dict[Exc, ExcHandler] = {}\n    self.set_default_exception_handlers()\n\n    self.auth: Optional[Union[Sequence[Callable], NOT_SET_TYPE]]\n\n    if callable(auth):\n        self.auth = [auth]\n    else:\n        self.auth = auth\n\n    self.throttle = throttle\n\n    self._routers: List[Tuple[str, Router]] = []\n    self.default_router = default_router or Router()\n    self.add_router(\"\", self.default_router)\n</code></pre>"},{"location":"reference/api/#ninja.main.NinjaAPI.delete","title":"<code>delete(path, *, auth=NOT_SET, throttle=NOT_SET, response=NOT_SET, operation_id=None, summary=None, description=None, tags=None, deprecated=None, by_alias=None, exclude_unset=None, exclude_defaults=None, exclude_none=None, url_name=None, include_in_schema=True, openapi_extra=None)</code>","text":"<p><code>DELETE</code> operation. See operations parameters reference.</p> Source code in <code>ninja/main.py</code> <pre><code>def delete(\n    self,\n    path: str,\n    *,\n    auth: Any = NOT_SET,\n    throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n    response: Any = NOT_SET,\n    operation_id: Optional[str] = None,\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    deprecated: Optional[bool] = None,\n    by_alias: Optional[bool] = None,\n    exclude_unset: Optional[bool] = None,\n    exclude_defaults: Optional[bool] = None,\n    exclude_none: Optional[bool] = None,\n    url_name: Optional[str] = None,\n    include_in_schema: bool = True,\n    openapi_extra: Optional[Dict[str, Any]] = None,\n) -&gt; Callable[[TCallable], TCallable]:\n    \"\"\"\n    `DELETE` operation. See &lt;a href=\"../operations-parameters\"&gt;operations\n    parameters&lt;/a&gt; reference.\n    \"\"\"\n    return self.default_router.delete(\n        path,\n        auth=auth is NOT_SET and self.auth or auth,\n        throttle=throttle is NOT_SET and self.throttle or throttle,\n        response=response,\n        operation_id=operation_id,\n        summary=summary,\n        description=description,\n        tags=tags,\n        deprecated=deprecated,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        url_name=url_name,\n        include_in_schema=include_in_schema,\n        openapi_extra=openapi_extra,\n    )\n</code></pre>"},{"location":"reference/api/#ninja.main.NinjaAPI.get","title":"<code>get(path, *, auth=NOT_SET, throttle=NOT_SET, response=NOT_SET, operation_id=None, summary=None, description=None, tags=None, deprecated=None, by_alias=None, exclude_unset=None, exclude_defaults=None, exclude_none=None, url_name=None, include_in_schema=True, openapi_extra=None)</code>","text":"<p><code>GET</code> operation. See operations parameters reference.</p> Source code in <code>ninja/main.py</code> <pre><code>def get(\n    self,\n    path: str,\n    *,\n    auth: Any = NOT_SET,\n    throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n    response: Any = NOT_SET,\n    operation_id: Optional[str] = None,\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    deprecated: Optional[bool] = None,\n    by_alias: Optional[bool] = None,\n    exclude_unset: Optional[bool] = None,\n    exclude_defaults: Optional[bool] = None,\n    exclude_none: Optional[bool] = None,\n    url_name: Optional[str] = None,\n    include_in_schema: bool = True,\n    openapi_extra: Optional[Dict[str, Any]] = None,\n) -&gt; Callable[[TCallable], TCallable]:\n    \"\"\"\n    `GET` operation. See &lt;a href=\"../operations-parameters\"&gt;operations\n    parameters&lt;/a&gt; reference.\n    \"\"\"\n    return self.default_router.get(\n        path,\n        auth=auth is NOT_SET and self.auth or auth,\n        throttle=throttle is NOT_SET and self.throttle or throttle,\n        response=response,\n        operation_id=operation_id,\n        summary=summary,\n        description=description,\n        tags=tags,\n        deprecated=deprecated,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        url_name=url_name,\n        include_in_schema=include_in_schema,\n        openapi_extra=openapi_extra,\n    )\n</code></pre>"},{"location":"reference/api/#ninja.main.NinjaAPI.get_operation_url_name","title":"<code>get_operation_url_name(operation, router)</code>","text":"<p>Get the default URL name to use for an operation if it wasn't explicitly provided.</p> Source code in <code>ninja/main.py</code> <pre><code>def get_operation_url_name(self, operation: \"Operation\", router: Router) -&gt; str:\n    \"\"\"\n    Get the default URL name to use for an operation if it wasn't\n    explicitly provided.\n    \"\"\"\n    return operation.view_func.__name__\n</code></pre>"},{"location":"reference/api/#ninja.main.NinjaAPI.patch","title":"<code>patch(path, *, auth=NOT_SET, throttle=NOT_SET, response=NOT_SET, operation_id=None, summary=None, description=None, tags=None, deprecated=None, by_alias=None, exclude_unset=None, exclude_defaults=None, exclude_none=None, url_name=None, include_in_schema=True, openapi_extra=None)</code>","text":"<p><code>PATCH</code> operation. See operations parameters reference.</p> Source code in <code>ninja/main.py</code> <pre><code>def patch(\n    self,\n    path: str,\n    *,\n    auth: Any = NOT_SET,\n    throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n    response: Any = NOT_SET,\n    operation_id: Optional[str] = None,\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    deprecated: Optional[bool] = None,\n    by_alias: Optional[bool] = None,\n    exclude_unset: Optional[bool] = None,\n    exclude_defaults: Optional[bool] = None,\n    exclude_none: Optional[bool] = None,\n    url_name: Optional[str] = None,\n    include_in_schema: bool = True,\n    openapi_extra: Optional[Dict[str, Any]] = None,\n) -&gt; Callable[[TCallable], TCallable]:\n    \"\"\"\n    `PATCH` operation. See &lt;a href=\"../operations-parameters\"&gt;operations\n    parameters&lt;/a&gt; reference.\n    \"\"\"\n    return self.default_router.patch(\n        path,\n        auth=auth is NOT_SET and self.auth or auth,\n        throttle=throttle is NOT_SET and self.throttle or throttle,\n        response=response,\n        operation_id=operation_id,\n        summary=summary,\n        description=description,\n        tags=tags,\n        deprecated=deprecated,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        url_name=url_name,\n        include_in_schema=include_in_schema,\n        openapi_extra=openapi_extra,\n    )\n</code></pre>"},{"location":"reference/api/#ninja.main.NinjaAPI.post","title":"<code>post(path, *, auth=NOT_SET, throttle=NOT_SET, response=NOT_SET, operation_id=None, summary=None, description=None, tags=None, deprecated=None, by_alias=None, exclude_unset=None, exclude_defaults=None, exclude_none=None, url_name=None, include_in_schema=True, openapi_extra=None)</code>","text":"<p><code>POST</code> operation. See operations parameters reference.</p> Source code in <code>ninja/main.py</code> <pre><code>def post(\n    self,\n    path: str,\n    *,\n    auth: Any = NOT_SET,\n    throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n    response: Any = NOT_SET,\n    operation_id: Optional[str] = None,\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    deprecated: Optional[bool] = None,\n    by_alias: Optional[bool] = None,\n    exclude_unset: Optional[bool] = None,\n    exclude_defaults: Optional[bool] = None,\n    exclude_none: Optional[bool] = None,\n    url_name: Optional[str] = None,\n    include_in_schema: bool = True,\n    openapi_extra: Optional[Dict[str, Any]] = None,\n) -&gt; Callable[[TCallable], TCallable]:\n    \"\"\"\n    `POST` operation. See &lt;a href=\"../operations-parameters\"&gt;operations\n    parameters&lt;/a&gt; reference.\n    \"\"\"\n    return self.default_router.post(\n        path,\n        auth=auth is NOT_SET and self.auth or auth,\n        throttle=throttle is NOT_SET and self.throttle or throttle,\n        response=response,\n        operation_id=operation_id,\n        summary=summary,\n        description=description,\n        tags=tags,\n        deprecated=deprecated,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        url_name=url_name,\n        include_in_schema=include_in_schema,\n        openapi_extra=openapi_extra,\n    )\n</code></pre>"},{"location":"reference/api/#ninja.main.NinjaAPI.put","title":"<code>put(path, *, auth=NOT_SET, throttle=NOT_SET, response=NOT_SET, operation_id=None, summary=None, description=None, tags=None, deprecated=None, by_alias=None, exclude_unset=None, exclude_defaults=None, exclude_none=None, url_name=None, include_in_schema=True, openapi_extra=None)</code>","text":"<p><code>PUT</code> operation. See operations parameters reference.</p> Source code in <code>ninja/main.py</code> <pre><code>def put(\n    self,\n    path: str,\n    *,\n    auth: Any = NOT_SET,\n    throttle: Union[BaseThrottle, List[BaseThrottle], NOT_SET_TYPE] = NOT_SET,\n    response: Any = NOT_SET,\n    operation_id: Optional[str] = None,\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    deprecated: Optional[bool] = None,\n    by_alias: Optional[bool] = None,\n    exclude_unset: Optional[bool] = None,\n    exclude_defaults: Optional[bool] = None,\n    exclude_none: Optional[bool] = None,\n    url_name: Optional[str] = None,\n    include_in_schema: bool = True,\n    openapi_extra: Optional[Dict[str, Any]] = None,\n) -&gt; Callable[[TCallable], TCallable]:\n    \"\"\"\n    `PUT` operation. See &lt;a href=\"../operations-parameters\"&gt;operations\n    parameters&lt;/a&gt; reference.\n    \"\"\"\n    return self.default_router.put(\n        path,\n        auth=auth is NOT_SET and self.auth or auth,\n        throttle=throttle is NOT_SET and self.throttle or throttle,\n        response=response,\n        operation_id=operation_id,\n        summary=summary,\n        description=description,\n        tags=tags,\n        deprecated=deprecated,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        url_name=url_name,\n        include_in_schema=include_in_schema,\n        openapi_extra=openapi_extra,\n    )\n</code></pre>"},{"location":"reference/csrf/","title":"CSRF","text":""},{"location":"reference/csrf/#what-is-csrf","title":"What is CSRF?","text":"<p>Cross Site Request Forgery occurs when a malicious website contains a link, a form button or some JavaScript that is intended to perform some action on your website, using the credentials (or location on the network, not covered by this documentation) of a logged-in user who visits the malicious site in their browser.</p>"},{"location":"reference/csrf/#how-to-protect-against-csrf-with-django-ninja","title":"How to protect against CSRF with Django Ninja","text":""},{"location":"reference/csrf/#use-an-authentication-method-not-automatically-embedded-in-the-request","title":"Use an authentication method not automatically embedded in the request","text":"<p>CSRF attacks rely on authentication methods that are automatically included in requests started from another site, like cookies or Basic access authentication. Using an authentication method that does not automatically gets embedded, such as the <code>Authorization: Bearer</code> header for exemple, mitigates this attack.</p>"},{"location":"reference/csrf/#use-djangos-built-in-csrf-protection","title":"Use Django's built-in CSRF protection","text":"<p>In case you are using the default Django authentication, which uses cookies, you must also use the default Django CSRF protection.</p> <p>By default, Django Ninja has CSRF protection turned OFF for all operations. To turn it on you need to use the <code>csrf</code> argument of the NinjaAPI class:</p> <pre><code>from ninja import NinjaAPI\n\napi = NinjaAPI(csrf=True)\n</code></pre> <p>Warning: It is not secure to use API's with cookie-based authentication! (like <code>CookieKey</code>, or <code>django_auth</code>) when csrf is turned OFF.</p> <p>Django Ninja will automatically enable csrf for Cookie based authentication</p> <pre><code>from ninja import NinjaAPI\nfrom ninja.security import APIKeyCookie\n\nclass CookieAuth(APIKeyCookie):\n    def authenticate(self, request, key):\n        return key == \"test\"\n\napi = NinjaAPI(auth=CookieAuth())\n</code></pre> <p>or django-auth based (which is inherited from cookie based auth):</p> <pre><code>from ninja import NinjaAPI\nfrom ninja.security import django_auth\n\napi = NinjaAPI(auth=django_auth)\n</code></pre>"},{"location":"reference/csrf/#django-ensure_csrf_cookie-decorator","title":"Django <code>ensure_csrf_cookie</code> decorator","text":"<p>You can use the Django ensure_csrf_cookie decorator on an unprotected route to make it include a <code>Set-Cookie</code> header for the CSRF token. Note that:</p> <ul> <li>The route decorator must be executed before (i.e. above) the ensure_csrf_cookie decorator).</li> <li>You must <code>csrf_exempt</code> that route.</li> <li>The <code>ensure_csrf_cookie</code> decorator works only on a Django <code>HttpResponse</code> (and subclasses like <code>JsonResponse</code>) and not on a dict like most Django Ninja decorators.</li> <li>If you set a Cookie based authentication (which includes <code>django_auth</code>) globally to your API, you'll have to specifically disable auth on that route (with <code>auth=None</code> in the route decorator) as Cookie based authentication would raise an Exception when applied to an unprotected route (for security reasons).</li> </ul> <p><pre><code>from django.http import HttpResponse\nfrom django.views.decorators.csrf import csrf_exempt, ensure_csrf_cookie\n\n@api.post(\"/csrf\")\n@ensure_csrf_cookie\n@csrf_exempt\ndef get_csrf_token(request):\n    return HttpResponse()\n</code></pre> A request to that route triggers a response with the adequate <code>Set-Cookie</code> header from Django.</p>"},{"location":"reference/csrf/#frontend-code","title":"Frontend code","text":"<p>You may use the Using CSRF protection with AJAX and Setting the token on the AJAX request part of the How to use Django\u2019s CSRF protection to know how to handle that CSRF protection token in your frontend code.</p>"},{"location":"reference/csrf/#a-word-about-cors","title":"A word about CORS","text":"<p>You may want to set-up your frontend and API on different sites (in that case, you may check django-cors-headers). While not directly related to CSRF, CORS (Cross-Origin Resource Sharing) may help in case you are defining the CSRF cookie on another site than the frontend consuming it, as this is not allowed by default by the Same-origin policy. You may check the django-cors-headers README then.</p>"},{"location":"reference/management-commands/","title":"Management Commands","text":"<p>Management commands require Django Ninja to be installed in Django's <code>INSTALLED_APPS</code> setting:</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'ninja',\n]\n</code></pre>"},{"location":"reference/operations-parameters/","title":"Operations parameters","text":""},{"location":"reference/operations-parameters/#openapi-schema-related","title":"OpenAPI Schema related","text":"<p>The following parameters interact with how the OpenAPI schema (and docs) are generated.</p>"},{"location":"reference/operations-parameters/#tags","title":"<code>tags</code>","text":"<p>You can group your API operations using the <code>tags</code> argument (<code>list[str]</code>).  <pre><code>@api.get(\"/hello/\")\ndef hello(request, name: str):\n    return {\"hello\": name}\n\n\n@api.post(\"/orders/\", tags=[\"orders\"])\ndef create_order(request, order: Order):\n    return {\"success\": True}\n</code></pre></p> <p>Tagged operations may be handled differently by various tools and libraries. For example, the Swagger UI uses tags to group the displayed operations.</p> <p></p>"},{"location":"reference/operations-parameters/#router-tags","title":"Router tags","text":"<p>You can use <code>tags</code> argument to apply tags to all operations declared by router:</p> <pre><code>api.add_router(\"/events/\", events_router, tags=[\"events\"])\n\n# or using constructor: \n\nrouter = Router(tags=[\"events\"])\n</code></pre>"},{"location":"reference/operations-parameters/#summary","title":"<code>summary</code>","text":"<p>A human-readable name for your operation.</p> <p>By default, it's generated by capitalizing your operation function name:</p> <pre><code>@api.get(\"/hello/\")\ndef hello(request, name: str):\n    return {\"hello\": name}\n</code></pre> <p></p> <p>If you want to override it or translate it to other language, use the <code>summary</code> argument in the <code>api</code> decorator.</p> <pre><code>@api.get(\"/hello/\", summary=\"Say Hello\")\ndef hello(request, name: str):\n    return {\"hello\": name}\n</code></pre> <p></p>"},{"location":"reference/operations-parameters/#description","title":"<code>description</code>","text":"<p>To provide more information about your operation, use either the <code>description</code> argument or normal Python docstrings:</p> <pre><code>@api.post(\"/orders/\", description=\"Creates an order and updates stock\")\ndef create_order(request, order: Order):\n    return {\"success\": True}\n</code></pre> <p></p> <p>When you need to provide a long multi line description, you can use Python <code>docstrings</code> for the function definition:</p> <pre><code>@api.post(\"/orders/\")\ndef create_order(request, order: Order):\n    \"\"\"\n    To create an order please provide:\n     - **first_name**\n     - **last_name**\n     - and **list of Items** *(product + amount)*\n    \"\"\"\n    return {\"success\": True}\n</code></pre> <p></p>"},{"location":"reference/operations-parameters/#operation_id","title":"<code>operation_id</code>","text":"<p>The OpenAPI <code>operationId</code> is an optional unique string used to identify an operation. If provided, these IDs must be unique among all operations described in your API.</p> <p>By default, Django Ninja sets it to <code>module name</code> + <code>function name</code>.</p> <p>If you want to set it individually for each operation, use the <code>operation_id</code> argument:</p> <pre><code>...\n@api.post(\"/tasks\", operation_id=\"create_task\")\ndef new_task(request):\n    ...\n</code></pre> <p>If you want to override global behavior, you can inherit the NinjaAPI instance and override the <code>get_openapi_operation_id</code> method.</p> <p>It will be called for each operation that you defined, so you can set your custom naming logic like this:</p> <pre><code>from ninja import NinjaAPI\n\nclass MySuperApi(NinjaAPI):\n\n    def get_openapi_operation_id(self, operation):\n        # here you can access operation ( .path , .view_func, etc) \n        return ...\n\napi = MySuperApi()\n\n@api.get(...)\n...\n</code></pre>"},{"location":"reference/operations-parameters/#deprecated","title":"<code>deprecated</code>","text":"<p>Mark an operation as deprecated without removing it by using the <code>deprecated</code> argument:</p> <pre><code>@api.post(\"/make-order/\", deprecated=True)\ndef some_old_method(request, order: str):\n    return {\"success\": True}\n</code></pre> <p>It will be marked as deprecated in the JSON Schema and also in the interactive OpenAPI docs:</p> <p></p>"},{"location":"reference/operations-parameters/#include_in_schema","title":"<code>include_in_schema</code>","text":"<p>If you need to include/exclude some operation from OpenAPI schema use <code>include_in_schema</code> argument:</p> <pre><code>@api.post(\"/hidden\", include_in_schema=False)\ndef some_hidden_operation(request):\n    pass\n</code></pre>"},{"location":"reference/operations-parameters/#openapi_extra","title":"openapi_extra","text":"<p>You can customize your OpenAPI schema for specific endpoint (detail OpenAPI Customize Options) <pre><code># You can set requestBody from openapi_extra\n@api.get(\n    \"/tasks\",\n    openapi_extra={\n        \"requestBody\": {\n            \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                        \"required\": [\"email\"],\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"name\": {\"type\": \"string\"},\n                            \"phone\": {\"type\": \"number\"},\n                            \"email\": {\"type\": \"string\"},\n                        },\n                    }\n                }\n            },\n            \"required\": True,\n        }\n    },\n)\ndef some_operation(request):\n    pass\n\n# You can add additional responses to the automatically generated schema\n@api.post(\n    \"/tasks\",\n    openapi_extra={\n        \"responses\": {\n            400: {\n                \"description\": \"Error Response\",\n            },\n            404: {\n                \"description\": \"Not Found Response\",\n            },\n        },\n    },\n)\ndef some_operation_2(request):\n    pass\n</code></pre></p>"},{"location":"reference/operations-parameters/#response-output-options","title":"Response output options","text":"<p>There are a few arguments that lets you tune response's output:</p>"},{"location":"reference/operations-parameters/#by_alias","title":"<code>by_alias</code>","text":"<p>Whether field aliases should be used as keys in the response (defaults to <code>False</code>).</p>"},{"location":"reference/operations-parameters/#exclude_unset","title":"<code>exclude_unset</code>","text":"<p>Whether fields that were not set when creating the schema, and have their default values, should be excluded from the response (defaults to <code>False</code>).</p>"},{"location":"reference/operations-parameters/#exclude_defaults","title":"<code>exclude_defaults</code>","text":"<p>Whether fields which are equal to their default values (whether set or otherwise) should be excluded from the response (defaults to <code>False</code>).</p>"},{"location":"reference/operations-parameters/#exclude_none","title":"<code>exclude_none</code>","text":"<p>Whether fields which are equal to <code>None</code> should be excluded from the response (defaults to <code>False</code>).</p>"},{"location":"reference/operations-parameters/#url_name","title":"url_name","text":"<p>Allows you to set api endpoint url name (using django path's naming) <pre><code>@api.post(\"/tasks\", url_name='tasks')\ndef some_operation(request):\n    pass\n\n# then you can get the url with\n\nreverse('api-1.0.0:tasks')\n</code></pre></p> <p>See the Reverse Resolution of URLs guide for more details.</p>"},{"location":"reference/operations-parameters/#specifying-servers","title":"Specifying servers","text":"<p>If you want to specify single or multiple servers for OpenAPI specification <code>servers</code> can be used when initializing NinjaAPI instance: <pre><code>from ninja import NinjaAPI\n\napi = NinjaAPI(\n        servers=[\n            {\"url\": \"https://stag.example.com\", \"description\": \"Staging env\"},\n            {\"url\": \"https://prod.example.com\", \"description\": \"Production env\"},\n        ]\n)\n</code></pre> This will allow switching between environments when using interactive OpenAPI docs: </p>"},{"location":"reference/settings/","title":"Django Settings","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>ninja/conf.py</code> <pre><code>class Settings(BaseModel):\n    # Pagination\n    PAGINATION_CLASS: str = Field(\n        \"ninja.pagination.LimitOffsetPagination\", alias=\"NINJA_PAGINATION_CLASS\"\n    )\n    PAGINATION_PER_PAGE: int = Field(100, alias=\"NINJA_PAGINATION_PER_PAGE\")\n    PAGINATION_MAX_PER_PAGE_SIZE: int = Field(100, alias=\"NINJA_MAX_PER_PAGE_SIZE\")\n    PAGINATION_MAX_LIMIT: int = Field(inf, alias=\"NINJA_PAGINATION_MAX_LIMIT\")  # type: ignore\n\n    # Throttling\n    NUM_PROXIES: Optional[int] = Field(None, alias=\"NINJA_NUM_PROXIES\")\n    DEFAULT_THROTTLE_RATES: Dict[str, Optional[str]] = Field(\n        {\n            \"auth\": \"10000/day\",\n            \"user\": \"10000/day\",\n            \"anon\": \"1000/day\",\n        },\n        alias=\"NINJA_DEFAULT_THROTTLE_RATES\",\n    )\n\n    FIX_REQUEST_FILES_METHODS: Set[str] = Field(\n        {\"PUT\", \"PATCH\", \"DELETE\"}, alias=\"NINJA_FIX_REQUEST_FILES_METHODS\"\n    )\n\n    COMPATIBILITY: bool = Field(True, alias=\"NINJA_COMPATIBILITY\")\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"tutorial/","title":"Tutorial - First Steps","text":"<p>This tutorial shows you how to use Django Shinobi with most of its features.</p> <p>This tutorial assumes that you know at least some basics of the Django Framework, like how to create a project and run it.</p>"},{"location":"tutorial/#installation","title":"Installation","text":"<pre><code>pip install django-shinobi\n</code></pre> <p>Note</p> <p>It is not required, but you can also put <code>ninja</code> to <code>INSTALLED_APPS</code>. In that case the OpenAPI/Swagger UI (or Redoc) will be loaded (faster) from the included JavaScript bundle (otherwise the JavaScript bundle comes from a CDN).</p>"},{"location":"tutorial/#create-a-django-project","title":"Create a Django project","text":"<p>Start a new Django project (or if you already have an existing Django project, skip to the next step).</p> <pre><code>django-admin startproject myproject\n</code></pre> <p>If you're starting a new project, it's recommended to set <code>NINJA_COMPATIBILITY</code> to <code>False</code> to get the  performance improvements.</p> <pre><code># myproject/settings.py\n\nNINJA_COMPATIBILITY = False\n</code></pre>"},{"location":"tutorial/#create-the-api","title":"Create the API","text":"<p>Let's create a module for our API. Create an <code>api.py</code> file in the same directory location as your Django project's root <code>urls.py</code>:</p> <p>Note</p> <p>For the sake of backwards compatibility, Shinobi still uses the <code>ninja</code> package name.</p> <pre><code>from ninja import NinjaAPI\n\napi = NinjaAPI()\n</code></pre> <p>Now go to <code>urls.py</code> and add the following:</p> <pre><code>from django.contrib import admin\nfrom django.urls import path\nfrom .api import api\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"api/\", api.urls),\n]\n</code></pre>"},{"location":"tutorial/#our-first-operation","title":"Our first operation","text":"<p>Django Shinobi comes with a decorator for each HTTP method (<code>GET</code>, <code>POST</code>, <code>PUT</code>, etc). In our <code>api.py</code> file, let's add in a simple \"hello world\" operation.</p> <pre><code>from ninja import NinjaAPI\n\napi = NinjaAPI()\n\n@api.get(\"/hello\")\ndef hello(request):\n    return \"Hello world\"\n</code></pre> <p>Now browsing to localhost:8000/api/hello will return a simple JSON response: <pre><code>\"Hello world\"\n</code></pre></p> <p>Success</p> <p>Continue on to Parsing input.</p>"},{"location":"tutorial/step2/","title":"Tutorial - Parsing Input","text":""},{"location":"tutorial/step2/#input-from-the-query-string","title":"Input from the query string","text":"<p>Let's change our operation to accept a name from the URL's query string. To do that, just add a <code>name</code> argument to our function.</p> <pre><code>@api.get(\"/hello\")\ndef hello(request, name):\n    return f\"Hello {name}\"\n</code></pre> <p>When we provide a name argument, we get the expected (HTTP 200) response.</p> <p>localhost:8000/api/hello?name=you:</p> <pre><code>\"Hello you\"\n</code></pre>"},{"location":"tutorial/step2/#defaults","title":"Defaults","text":"<p>Not providing the argument will return an HTTP 422 error response.</p> <p>localhost:8000/api/hello:</p> <pre><code>{\n  \"detail\": [\n    {\n      \"loc\": [\"query\", \"name\"],\n      \"msg\": \"field required\",\n      \"type\": \"value_error.missing\"\n    }\n  ]\n}\n</code></pre> <p>We can specify a default for the <code>name</code> argument in case it isn't provided:</p> <pre><code>@api.get(\"/hello\")\ndef hello(request, name=\"world\"):\n    return f\"Hello {name}\"\n</code></pre>"},{"location":"tutorial/step2/#input-types","title":"Input types","text":"<p>Django Ninja uses standard Python type hints to format the input types. If no type is provided then a string is assumed (but it is good practice to provide type hints for all your arguments).</p> <p>Let's add a second operation that does some basic math with integers.</p> <pre><code>@api.get(\"/hello\")\ndef hello(request, name: str = \"world\"):\n    return f\"Hello {name}\"\n\n@api.get(\"/math\")\ndef math(request, a: int, b: int):\n    return {\"add\": a + b, \"multiply\": a * b}\n</code></pre> <p>localhost:8000/api/math?a=2&amp;b=3:</p> <pre><code>{\n  \"add\": 5,\n  \"multiply\": 6\n}\n</code></pre>"},{"location":"tutorial/step2/#input-from-the-path","title":"Input from the path","text":"<p>You can declare path \"parameters\" with the same syntax used by Python format-strings.</p> <p>Any parameters found in the path string will be passed to your function as arguments, rather than expecting them from the query string.</p> <pre><code>@api.get(\"/math/{a}and{b}\")\ndef math(request, a: int, b: int):\n    return {\"add\": a + b, \"multiply\": a * b}\n</code></pre> <p>Now we access the math operation from localhost:8000/api/math/2and3.</p>"},{"location":"tutorial/step2/#input-from-the-request-body","title":"Input from the request body","text":"<p>We are going to change our <code>hello</code> operation to use HTTP <code>POST</code> instead, and take arguments from the request body.</p> <p>To specify that arguments come from the body, we need to declare a Schema.</p> <pre><code>from ninja import NinjaAPI, Schema\n\napi = NinjaAPI()\n\nclass HelloSchema(Schema):\n    name: str = \"world\"\n\n@api.post(\"/hello\")\ndef hello(request, data: HelloSchema):\n    return f\"Hello {data.name}\"\n</code></pre>"},{"location":"tutorial/step2/#self-documenting-api","title":"Self-documenting API","text":"<p>Accessing localhost:8000/api/hello now results in a HTTP 405 error response, since we need to POST to this URL instead.</p> <p>An easy way to do this is to use the Swagger documentation that is automatically created for us, at default URL of \"/docs\" (appended to our API url root).</p> <ol> <li>Visit localhost:8000/api/docs to see the operations we have created</li> <li>Open the <code>/api/hello</code> operation</li> <li>Click \"Try it out\"</li> <li>Change the request body</li> <li>Click \"Execute\"</li> </ol> <p>Success</p> <p>Continue on to Handling responses</p>"},{"location":"tutorial/step3/","title":"Tutorial - Handling Responses","text":""},{"location":"tutorial/step3/#define-a-response-schema","title":"Define a response Schema","text":"<p>Django Shinobi allows you to define the schema of your responses both for validation and documentation purposes.</p> <p>We'll create a third operation that will return information about the current Django user.</p> <pre><code>from ninja import Schema\n\nclass UserSchema(Schema):\n    username: str\n    is_authenticated: bool\n    # Unauthenticated users don't have the following fields, so provide defaults.\n    email: str = None\n    first_name: str = None\n    last_name: str = None\n\n@api.get(\"/me\", response=UserSchema)\ndef me(request):\n    return request.user\n</code></pre> <p>This will convert the Django <code>User</code> object into a dictionary of only the defined fields.</p>"},{"location":"tutorial/step3/#multiple-response-types","title":"Multiple response types","text":"<p>Let's return a different response if the current user is not authenticated.</p> <pre><code>class UserSchema(Schema):\n    username: str\n    email: str\n    first_name: str\n    last_name: str\n\nclass Error(Schema):\n    message: str\n\n@api.get(\"/me\", response={200: UserSchema, 403: Error})\ndef me(request):\n    if not request.user.is_authenticated:\n        return 403, {\"message\": \"Please sign in first\"}\n    return request.user \n</code></pre> <p>As you see, you can return a 2-part tuple which will be interpreted as the HTTP response code and the data.</p> <p>Success</p> <p>That concludes the tutorial! Check out the Other Tutorials or the How-to Guides for more information.</p>"},{"location":"tutorial/other/crud/","title":"CRUD example","text":"<p>CRUD  - Create, Retrieve, Update, Delete are the four basic functions of persistent storage.</p> <p>This example will show you how to implement these functions with Django Ninja.</p> <p>Let's say you have the following Django models that you need to perform these operations on:</p> <pre><code>class Department(models.Model):\n    title = models.CharField(max_length=100)\n\nclass Employee(models.Model):\n    first_name = models.CharField(max_length=100)\n    last_name = models.CharField(max_length=100)\n    department = models.ForeignKey(Department, on_delete=models.CASCADE)\n    birthdate = models.DateField(null=True, blank=True)\n    cv = models.FileField(null=True, blank=True)\n</code></pre> <p>Now let's create CRUD operations for the Employee model.</p>"},{"location":"tutorial/other/crud/#create","title":"Create","text":"<p>To create an employee lets define an INPUT schema:</p> <pre><code>from datetime import date\nfrom ninja import Schema\n\nclass EmployeeIn(Schema):\n    first_name: str\n    last_name: str\n    department_id: int = None\n    birthdate: date = None\n</code></pre> <p>This schema will be our input payload:</p> <pre><code>@api.post(\"/employees\")\ndef create_employee(request, payload: EmployeeIn):\n    employee = Employee.objects.create(**payload.dict())\n    return {\"id\": employee.id}\n</code></pre> <p>Tip</p> <p><code>Schema</code> objects have <code>.dict()</code> method with all the schema attributes represented as a dict.</p> <p>You can pass it as <code>**kwargs</code> to the Django model's <code>create</code> method (or model <code>__init__</code>).</p> <p>See the recipe below for handling the file upload (when using Django models):</p> <pre><code>from ninja import UploadedFile, File\n\n@api.post(\"/employees\")\ndef create_employee(request, payload: EmployeeIn, cv: File[UploadedFile]):\n    payload_dict = payload.dict()\n    employee = Employee(**payload_dict)\n    employee.cv.save(cv.name, cv) # will save model instance as well\n    return {\"id\": employee.id}\n</code></pre> <p>If you just need to handle a file upload:</p> <pre><code>from django.core.files.storage import FileSystemStorage\nfrom ninja import UploadedFile, File\n\nSTORAGE = FileSystemStorage()\n\n@api.post(\"/upload\")\ndef create_upload(request, cv: File[UploadedFile]):\n    filename = STORAGE.save(cv.name, cv)\n    # Handle things further\n</code></pre>"},{"location":"tutorial/other/crud/#retrieve","title":"Retrieve","text":""},{"location":"tutorial/other/crud/#single-object","title":"Single object","text":"<p>Now to get employee we will define a schema that will describe what our responses will look like. Here we will basically use the same schema as <code>EmployeeIn</code>, but will add an extra attribute <code>id</code>:</p> <pre><code>class EmployeeOut(Schema):\n    id: int\n    first_name: str\n    last_name: str\n    department_id: int = None\n    birthdate: date = None\n</code></pre> <p>Note</p> <p>Defining response schemas are not really required, but when you do define it you will get results validation, documentation and automatic ORM objects to JSON conversions.</p> <p>We will use this schema as the <code>response</code> type for our <code>GET</code> employee view:</p> <pre><code>@api.get(\"/employees/{employee_id}\", response=EmployeeOut)\ndef get_employee(request, employee_id: int):\n    employee = get_object_or_404(Employee, id=employee_id)\n    return employee\n</code></pre> <p>Notice that we simply returned an employee ORM object, without a need to convert it to a dict. The <code>response</code> schema does automatic result validation and conversion to JSON: <pre><code>@api.get(\"/employees/{employee_id}\", response=EmployeeOut)\ndef get_employee(request, employee_id: int):\n    employee = get_object_or_404(Employee, id=employee_id)\n    return employee\n</code></pre></p>"},{"location":"tutorial/other/crud/#list-of-objects","title":"List of objects","text":"<p>To output a list of employees, we can reuse the same <code>EmployeeOut</code> schema. We will just set the <code>response</code> schema to a List of <code>EmployeeOut</code>. <pre><code>from typing import List\n\n@api.get(\"/employees\", response=List[EmployeeOut])\ndef list_employees(request):\n    qs = Employee.objects.all()\n    return qs\n</code></pre></p> <p>Another cool trick - notice we just returned a Django ORM queryset:</p> <p><pre><code>@api.get(\"/employees\", response=List[EmployeeOut])\ndef list_employees(request):\n    qs = Employee.objects.all()\n    return qs\n</code></pre> It automatically gets evaluated, validated and converted to a JSON list!</p>"},{"location":"tutorial/other/crud/#update","title":"Update","text":"<p>Update is pretty trivial. We just use the <code>PUT</code> method and also pass <code>employee_id</code>:</p> <pre><code>@api.put(\"/employees/{employee_id}\")\ndef update_employee(request, employee_id: int, payload: EmployeeIn):\n    employee = get_object_or_404(Employee, id=employee_id)\n    for attr, value in payload.dict().items():\n        setattr(employee, attr, value)\n    employee.save()\n    return {\"success\": True}\n</code></pre> <p>Note</p> <p>Here we used the <code>payload.dict</code> method to set all object attributes:</p> <p><code>for attr, value in payload.dict().items()</code></p> <p>You can also do this more explicit:</p> <pre><code>employee.first_name = payload.first_name\nemployee.last_name = payload.last_name\nemployee.department_id = payload.department_id\nemployee.birthdate = payload.birthdate\n</code></pre> <p>Partial updates</p> <p>To allow the user to make partial updates, use <code>payload.dict(exclude_unset=True).items()</code>. This ensures that only the specified fields get updated.</p> <p>Enforcing strict field validation</p> <p>By default, any provided fields that don't exist in the schema will be silently ignored. To raise an error for these invalid fields, you can set <code>extra = \"forbid\"</code> in the schema's Config class. For example:</p> <pre><code>class EmployeeIn(Schema):\n    # your fields here...\n\n    class Config:\n        extra = \"forbid\"\n</code></pre>"},{"location":"tutorial/other/crud/#delete","title":"Delete","text":"<p>Delete is also pretty simple. We just get employee by <code>id</code> and delete it from the DB:</p> <pre><code>@api.delete(\"/employees/{employee_id}\")\ndef delete_employee(request, employee_id: int):\n    employee = get_object_or_404(Employee, id=employee_id)\n    employee.delete()\n    return {\"success\": True}\n</code></pre>"},{"location":"tutorial/other/crud/#final-code","title":"Final code","text":"<p>Here's a full CRUD example:</p> <pre><code>from datetime import date\nfrom typing import List\nfrom ninja import NinjaAPI, Schema\nfrom django.shortcuts import get_object_or_404\nfrom employees.models import Employee\n\n\napi = NinjaAPI()\n\n\nclass EmployeeIn(Schema):\n    first_name: str\n    last_name: str\n    department_id: int = None\n    birthdate: date = None\n\n\nclass EmployeeOut(Schema):\n    id: int\n    first_name: str\n    last_name: str\n    department_id: int = None\n    birthdate: date = None\n\n\n@api.post(\"/employees\")\ndef create_employee(request, payload: EmployeeIn):\n    employee = Employee.objects.create(**payload.dict())\n    return {\"id\": employee.id}\n\n\n@api.get(\"/employees/{employee_id}\", response=EmployeeOut)\ndef get_employee(request, employee_id: int):\n    employee = get_object_or_404(Employee, id=employee_id)\n    return employee\n\n\n@api.get(\"/employees\", response=List[EmployeeOut])\ndef list_employees(request):\n    qs = Employee.objects.all()\n    return qs\n\n\n@api.put(\"/employees/{employee_id}\")\ndef update_employee(request, employee_id: int, payload: EmployeeIn):\n    employee = get_object_or_404(Employee, id=employee_id)\n    for attr, value in payload.dict().items():\n        setattr(employee, attr, value)\n    employee.save()\n    return {\"success\": True}\n\n\n@api.delete(\"/employees/{employee_id}\")\ndef delete_employee(request, employee_id: int):\n    employee = get_object_or_404(Employee, id=employee_id)\n    employee.delete()\n    return {\"success\": True}\n</code></pre>"},{"location":"tutorial/other/video/","title":"Video Tutorials","text":""},{"location":"tutorial/other/video/#sneaky-rest-apis-with-django-ninja","title":"Sneaky REST APIs With Django Ninja","text":"<p>realpython.com/lessons/sneaky-rest-apis-with-django-ninja-overview/</p>"},{"location":"tutorial/other/video/#creating-a-crud-api-with-django-ninja-by-bugbytes-english","title":"Creating a CRUD API with Django-Ninja by BugBytes (English)","text":""}]}